<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSD: lsd.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lsd.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
LSD module code. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>rafael grompone von gioi (<a href="mailto:grompone@gmail.com">grompone@gmail.com</a>)</dd></dl>

<p>
Definition in file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include &lt;float.h&gt;</code><br>
<code>#include "<a class="el" href="lsd_8h-source.html">lsd.h</a>"</code><br>

<p>
Include dependency graph for lsd.c:<p><center><img src="lsd_8c__incl.png" border="0" usemap="#lsd.c_map" alt="Include dependency graph"></center>
<map name="lsd.c_map">
<area href="lsd_8h.html" shape="rect" coords="440,7,490,34" alt="">
</map>

<p>
<a href="lsd_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structcoorlist.html">coorlist</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chained list of coordinates. </em> <a href="structcoorlist.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structpoint.html">point</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A point (or pixel). </em> <a href="structpoint.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structrect.html">rect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rectangle structure: line segment with width. </em> <a href="structrect.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structrect__iter.html">rect_iter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rectangle points iterator. </em> <a href="structrect__iter.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a0">M_LN10</a>&nbsp;&nbsp;&nbsp;2.30258509299404568402</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ln(10) </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a1">M_PI</a>&nbsp;&nbsp;&nbsp;3.14159265358979323846</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PI. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a2">FALSE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a3">TRUE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a4">NOTDEF</a>&nbsp;&nbsp;&nbsp;-1024.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels with undefined gradient. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a5">M_3_2_PI</a>&nbsp;&nbsp;&nbsp;4.71238898038</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3/2 pi </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a6">M_2__PI</a>&nbsp;&nbsp;&nbsp;6.28318530718</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2 pi </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a7">NOTUSED</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels not used in yet. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a8">USED</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels already used in detection. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a>&nbsp;&nbsp;&nbsp;100.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Doubles relative error factor. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a10">log_gamma</a>(x)&nbsp;&nbsp;&nbsp;((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a11">TABSIZE</a>&nbsp;&nbsp;&nbsp;100000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the table to store already computed inverse values. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a12">error</a> (char *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fatal error, print a message to standard-error output and exit. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a13">double_equal</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare doubles by relative error. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a14">dist</a> (double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes Euclidean distance between point (x1,y1) and point (x2,y2). </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a15">free_ntuple_list</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in n-tuple 'in'. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a16">new_ntuple_list</a> (unsigned int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an n-tuple list and allocate memory for one element. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a17">enlarge_ntuple_list</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> n_tuple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enlarge the allocated memory of an n-tuple list. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a18">add_5tuple</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> out, double v1, double v2, double v3, double v4, double v5)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a 5-tuple to an n-tuple list. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a19">free_image_char</a> (<a class="el" href="structimage__char__s.html">image_char</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_char 'i'. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a20">new_image_char</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_char of size 'xsize' times 'ysize'. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a21">new_image_char_ini</a> (unsigned int xsize, unsigned int ysize, unsigned char fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_char of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a22">free_image_int</a> (<a class="el" href="structimage__int__s.html">image_int</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_int 'i'. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a23">new_image_int</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_int of size 'xsize' times 'ysize'. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a24">new_image_int_ini</a> (unsigned int xsize, unsigned int ysize, int fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_int of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a25">free_image_double</a> (<a class="el" href="structimage__double__s.html">image_double</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_double 'i'. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a26">new_image_double</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_double of size 'xsize' times 'ysize'. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a27">new_image_double_ini</a> (unsigned int xsize, unsigned int ysize, double fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_double of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a28">gaussian_kernel</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> kernel, double sigma, double mean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a Gaussian kernel of length 'kernel-&gt;dim', standard deviation 'sigma', and centered at value 'mean'. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a29">gaussian_sampler</a> (<a class="el" href="structimage__double__s.html">image_double</a> in, double scale, double sigma_scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a30">ll_angle</a> (<a class="el" href="structimage__double__s.html">image_double</a> in, double threshold, struct <a class="el" href="structcoorlist.html">coorlist</a> **list_p, void **mem_p, <a class="el" href="structimage__double__s.html">image_double</a> *modgrad, unsigned int n_bins, double max_grad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the direction of the level line of 'in' at each point. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a31">isaligned</a> (int x, int y, <a class="el" href="structimage__double__s.html">image_double</a> angles, double theta, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is point (x,y) aligned to angle theta, up to precision 'prec'? </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a32">angle_diff</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value angle difference. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a33">angle_diff_signed</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signed angle difference. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a34">log_gamma_lanczos</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a35">log_gamma_windschitl</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a36">nfa</a> (int n, int k, double p, double logNT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes -log10(NFA). </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a37">rect_copy</a> (struct <a class="el" href="structrect.html">rect</a> *in, struct <a class="el" href="structrect.html">rect</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy one rectangle structure to another. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a38">inter_low</a> (double x, double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a39">inter_hi</a> (double x, double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger of 'y1' and 'y2'. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a40">ri_del</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used by a rectangle iterator. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a41">ri_end</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the iterator finished the full iteration. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a42">ri_inc</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment a rectangle iterator. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a43">ri_ini</a> (struct <a class="el" href="structrect.html">rect</a> *r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize a rectangle iterator. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a44">rect_nfa</a> (struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__double__s.html">image_double</a> angles, double logNT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a rectangle's NFA value. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a45">get_theta</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int reg_size, double x, double y, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute region's angle as the principal inertia axis of the region. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a46">region2rect</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a rectangle that covers a region of points. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a47">region_grow</a> (int x, int y, <a class="el" href="structimage__double__s.html">image_double</a> angles, struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, double *reg_angle, <a class="el" href="structimage__char__s.html">image_char</a> used, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a region of pixels that share the same angle, up to a tolerance 'prec', starting at point (x,y). </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a48">rect_improve</a> (struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__double__s.html">image_double</a> angles, double logNT, double eps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try some rectangles variations to improve NFA value. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a49">reduce_region_radius</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__char__s.html">image_char</a> used, <a class="el" href="structimage__double__s.html">image_double</a> angles, double density_th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce the region size, by elimination the points far from the starting point, until that leads to rectangle with the right density of region points or to discard the region if too small. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a50">refine</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__char__s.html">image_char</a> used, <a class="el" href="structimage__double__s.html">image_double</a> angles, double density_th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine a rectangle. </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a51">LineSegmentDetection</a> (<a class="el" href="structimage__double__s.html">image_double</a> image, double scale, double sigma_scale, double quant, double ang_th, double eps, double density_th, int n_bins, double max_grad, <a class="el" href="structimage__int__s.html">image_int</a> *region)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Full Interface. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a52">lsd_scale</a> (<a class="el" href="structimage__double__s.html">image_double</a> image, double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a53">lsd</a> (<a class="el" href="structimage__double__s.html">image_double</a> image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface. </em> <a href="#a53"></a><em><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a2" doxytag="lsd.c::FALSE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FALSE&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00089">89</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="lsd.c::log_gamma" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define log_gamma</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x. 
<p>
When x&gt;15 use <a class="el" href="lsd_8c.html#a35">log_gamma_windschitl()</a>, otherwise use <a class="el" href="lsd_8c.html#a34">log_gamma_lanczos()</a>. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00913">913</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00962">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="lsd.c::M_2__PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_2__PI&nbsp;&nbsp;&nbsp;6.28318530718
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
2 pi 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00103">103</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00819">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00831">angle_diff_signed()</a>, and <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="lsd.c::M_3_2_PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_3_2_PI&nbsp;&nbsp;&nbsp;4.71238898038
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
3/2 pi 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00100">100</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="lsd.c::M_LN10" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_LN10&nbsp;&nbsp;&nbsp;2.30258509299404568402
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ln(10) 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00080">80</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00962">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="lsd.c::M_PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_PI&nbsp;&nbsp;&nbsp;3.14159265358979323846
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
PI. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00085">85</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00819">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00831">angle_diff_signed()</a>, <a class="el" href="lsd_8c-source.html#l01456">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l01644">rect_improve()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="lsd.c::NOTDEF" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NOTDEF&nbsp;&nbsp;&nbsp;-1024.0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels with undefined gradient. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00097">97</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l00652">ll_angle()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="lsd.c::NOTUSED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NOTUSED&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels not used in yet. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00106">106</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="lsd.c::RELATIVE_ERROR_FACTOR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RELATIVE_ERROR_FACTOR&nbsp;&nbsp;&nbsp;100.0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Doubles relative error factor. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00142">142</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00155">double_equal()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="lsd.c::TABSIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TABSIZE&nbsp;&nbsp;&nbsp;100000
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Size of the table to store already computed inverse values. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00918">918</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00962">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="lsd.c::TRUE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TRUE&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00093">93</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00155">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="lsd.c::USED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define USED&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels already used in detection. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00109">109</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01592">region_grow()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a18" doxytag="lsd.c::add_5tuple" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void add_5tuple </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v3</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v4</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v5</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a 5-tuple to an n-tuple list. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00250">250</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00059">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00232">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h-source.html#l00058">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, <a class="el" href="lsd_8h-source.html#l00057">ntuple_list_s::size</a>, and <a class="el" href="lsd_8h-source.html#l00060">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00252 {
00253   <span class="comment">/* check parameters */</span>
00254   <span class="keywordflow">if</span>( out == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"add_5tuple: invalid n-tuple input."</span>);
00255   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> != 5 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"add_5tuple: the n-tuple must be a 5-tuple."</span>);
00256 
00257   <span class="comment">/* if needed, alloc more tuples to 'out' */</span>
00258   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> == out-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> ) <a class="code" href="lsd_8c.html#a17">enlarge_ntuple_list</a>(out);
00259   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"add_5tuple: invalid n-tuple input."</span>);
00260 
00261   <span class="comment">/* add new 5-tuple */</span>
00262   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 0 ] = v1;
00263   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 1 ] = v2;
00264   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 2 ] = v3;
00265   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 3 ] = v4;
00266   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 4 ] = v5;
00267 
00268   <span class="comment">/* update number of tuples counter */</span>
00269   out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>++;
00270 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a18_cgraph.png" border="0" usemap="#lsd_8c_a18_cgraph_map" alt=""></center>
<map name="lsd_8c_a18_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="145,7,278,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="328,33,378,59" alt="">
</map>
<a class="anchor" name="a32" doxytag="lsd.c::angle_diff" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double angle_diff </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Absolute value angle difference. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00819">819</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00103">M_2__PI</a>, and <a class="el" href="lsd_8c-source.html#l00085">M_PI</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01456">get_theta()</a>.
<p>
<div class="fragment"><pre>00820 {
00821   a -= b;
00822   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00823   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00824   <span class="keywordflow">if</span>( a &lt; 0.0 ) a = -a;
00825   <span class="keywordflow">return</span> a;
00826 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="lsd.c::angle_diff_signed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double angle_diff_signed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signed angle difference. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00831">831</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00103">M_2__PI</a>, and <a class="el" href="lsd_8c-source.html#l00085">M_PI</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.
<p>
<div class="fragment"><pre>00832 {
00833   a -= b;
00834   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00835   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00836   <span class="keywordflow">return</span> a;
00837 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="lsd.c::dist" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double dist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes Euclidean distance between point (x1,y1) and point (x2,y2). 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00181">181</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.
<p>
<div class="fragment"><pre>00182 {
00183   <span class="keywordflow">return</span> sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
00184 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="lsd.c::double_equal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int double_equal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare doubles by relative error. 
<p>
The resulting rounding error after floating point computations depend on the specific operations done. The same number computed by different algorithms could present different rounding errors. For a useful comparison, an estimation of the relative rounding error should be considered and compared to a factor times EPS. The factor should be related to the cumulated rounding error in the chain of computation. Here, as a simplification, a fixed factor is used. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00155">155</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00142">RELATIVE_ERROR_FACTOR</a>, and <a class="el" href="lsd_8c-source.html#l00093">TRUE</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01456">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01187">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01165">inter_low()</a>, and <a class="el" href="lsd_8c-source.html#l00962">nfa()</a>.
<p>
<div class="fragment"><pre>00156 {
00157   <span class="keywordtype">double</span> abs_diff,aa,bb,abs_max;
00158 
00159   <span class="comment">/* trivial case */</span>
00160   <span class="keywordflow">if</span>( a == b ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
00161 
00162   abs_diff = fabs(a-b);
00163   aa = fabs(a);
00164   bb = fabs(b);
00165   abs_max = aa &gt; bb ? aa : bb;
00166 
00167   <span class="comment">/* DBL_MIN is the smallest normalized number, thus, the smallest</span>
00168 <span class="comment">     number whose relative error is bounded by DBL_EPSILON. For</span>
00169 <span class="comment">     smaller numbers, the same quantization steps as for DBL_MIN</span>
00170 <span class="comment">     are used. Then, for smaller numbers, a meaningful "relative"</span>
00171 <span class="comment">     error should be computed by dividing the difference by DBL_MIN. */</span>
00172   <span class="keywordflow">if</span>( abs_max &lt; DBL_MIN ) abs_max = DBL_MIN;
00173 
00174   <span class="comment">/* equal if relative error &lt;= factor x eps */</span>
00175   <span class="keywordflow">return</span> (abs_diff / abs_max) &lt;= (<a class="code" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a> * DBL_EPSILON);
00176 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="lsd.c::enlarge_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void enlarge_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n_tuple</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enlarge the allocated memory of an n-tuple list. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00232">232</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00059">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h-source.html#l00058">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, and <a class="el" href="lsd_8h-source.html#l00060">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00250">add_5tuple()</a>, and <a class="el" href="lsd_8c-source.html#l00448">gaussian_kernel()</a>.
<p>
<div class="fragment"><pre>00233 {
00234   <span class="comment">/* check parameters */</span>
00235   <span class="keywordflow">if</span>( n_tuple == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> == 0 )
00236     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"enlarge_ntuple_list: invalid n-tuple."</span>);
00237 
00238   <span class="comment">/* duplicate number of tuples */</span>
00239   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> *= 2;
00240 
00241   <span class="comment">/* realloc memory */</span>
00242   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) realloc( (<span class="keywordtype">void</span> *) n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>,
00243                       n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> * n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00244   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00245 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a17_cgraph.png" border="0" usemap="#lsd_8c_a17_cgraph_map" alt=""></center>
<map name="lsd_8c_a17_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="192,8,242,34" alt="">
</map>
<a class="anchor" name="a12" doxytag="lsd.c::error" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error, print a message to standard-error output and exit. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00133">133</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00250">add_5tuple()</a>, <a class="el" href="lsd_8c-source.html#l00232">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00280">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00387">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00336">free_image_int()</a>, <a class="el" href="lsd_8c-source.html#l00194">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00448">gaussian_kernel()</a>, <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l01456">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01187">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01165">inter_low()</a>, <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00652">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00291">new_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00316">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00398">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00347">new_image_int()</a>, <a class="el" href="lsd_8c-source.html#l00206">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00962">nfa()</a>, <a class="el" href="lsd_8c-source.html#l01071">rect_copy()</a>, <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01835">refine()</a>, <a class="el" href="lsd_8c-source.html#l01499">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01592">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l01202">ri_del()</a>, <a class="el" href="lsd_8c-source.html#l01213">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01229">ri_inc()</a>, and <a class="el" href="lsd_8c-source.html#l01299">ri_ini()</a>.
<p>
<div class="fragment"><pre>00134 {
00135   fprintf(stderr,<span class="stringliteral">"LSD Error: %s\n"</span>,msg);
00136   exit(EXIT_FAILURE);
00137 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="lsd.c::free_image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_char </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_char 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00280">280</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, and <a class="el" href="lsd_8h.html#a1">image_char</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00281 {
00282   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00283     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_image_char: invalid input image."</span>);
00284   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> );
00285   free( (<span class="keywordtype">void</span> *) i );
00286 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a19_cgraph.png" border="0" usemap="#lsd_8c_a19_cgraph_map" alt=""></center>
<map name="lsd_8c_a19_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="178,8,229,34" alt="">
</map>
<a class="anchor" name="a25" doxytag="lsd.c::free_image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_double 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00387">387</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, and <a class="el" href="lsd_8h.html#a3">image_double</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00388 {
00389   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00390     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_image_double: invalid input image."</span>);
00391   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> );
00392   free( (<span class="keywordtype">void</span> *) i );
00393 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a25_cgraph.png" border="0" usemap="#lsd_8c_a25_cgraph_map" alt=""></center>
<map name="lsd_8c_a25_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="194,8,245,34" alt="">
</map>
<a class="anchor" name="a22" doxytag="lsd.c::free_image_int" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_int </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_int 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00336">336</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00102">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, and <a class="el" href="lsd_8h.html#a2">image_int</a>.
<p>
<div class="fragment"><pre>00337 {
00338   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL )
00339     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_image_int: invalid input image."</span>);
00340   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> );
00341   free( (<span class="keywordtype">void</span> *) i );
00342 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a22_cgraph.png" border="0" usemap="#lsd_8c_a22_cgraph_map" alt=""></center>
<map name="lsd_8c_a22_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="168,8,218,34" alt="">
</map>
<a class="anchor" name="a15" doxytag="lsd.c::free_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in n-tuple 'in'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00194">194</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, and <a class="el" href="lsd_8h-source.html#l00060">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>.
<p>
<div class="fragment"><pre>00195 {
00196   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00197     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_ntuple_list: invalid n-tuple input."</span>);
00198   free( (<span class="keywordtype">void</span> *) in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> );
00199   free( (<span class="keywordtype">void</span> *) in );
00200 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a15_cgraph.png" border="0" usemap="#lsd_8c_a15_cgraph_map" alt=""></center>
<map name="lsd_8c_a15_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="170,8,221,34" alt="">
</map>
<a class="anchor" name="a28" doxytag="lsd.c::gaussian_kernel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void gaussian_kernel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>mean</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a Gaussian kernel of length 'kernel-&gt;dim', standard deviation 'sigma', and centered at value 'mean'. 
<p>
For example, if mean=0.5, the Gaussian will be centered in the middle point between values 'kernel-&gt;values[0]' and 'kernel-&gt;values[1]'. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00448">448</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00059">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00232">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h-source.html#l00058">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, <a class="el" href="lsd_8h-source.html#l00057">ntuple_list_s::size</a>, and <a class="el" href="lsd_8h-source.html#l00060">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>.
<p>
<div class="fragment"><pre>00449 {
00450   <span class="keywordtype">double</span> sum = 0.0;
00451   <span class="keywordtype">double</span> val;
00452   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00453 
00454   <span class="comment">/* check parameters */</span>
00455   <span class="keywordflow">if</span>( kernel == NULL || kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00456     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_kernel: invalid n-tuple 'kernel'."</span>);
00457   <span class="keywordflow">if</span>( sigma &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_kernel: 'sigma' must be positive."</span>);
00458 
00459   <span class="comment">/* compute Gaussian kernel */</span>
00460   <span class="keywordflow">if</span>( kernel-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> &lt; 1 ) <a class="code" href="lsd_8c.html#a17">enlarge_ntuple_list</a>(kernel);
00461   kernel-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 1;
00462   <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00463     {
00464       val = ( (<span class="keywordtype">double</span>) i - mean ) / sigma;
00465       kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] = exp( -0.5 * val * val );
00466       sum += kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00467     }
00468 
00469   <span class="comment">/* normalization */</span>
00470   <span class="keywordflow">if</span>( sum &gt;= 0.0 ) <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++) kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] /= sum;
00471 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a28_cgraph.png" border="0" usemap="#lsd_8c_a28_cgraph_map" alt=""></center>
<map name="lsd_8c_a28_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="177,7,310,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="360,33,410,59" alt="">
</map>
<a class="anchor" name="a29" doxytag="lsd.c::gaussian_sampler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> gaussian_sampler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling. 
<p>
For example, scale=0.8 will give a result at 80% of the original size.<p>
The image is convolved with a Gaussian kernel <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} \]" src="form_0.png">
<p>
 before the sub-sampling to prevent aliasing.<p>
The standard deviation sigma given by:<ul>
<li>sigma = sigma_scale / scale, if scale &lt; 1.0</li><li>sigma = sigma_scale, if scale &gt;= 1.0</li></ul>
<p>
To be able to sub-sample at non-integer steps, some interpolation is needed. In this implementation, the interpolation is done by the Gaussian kernel, so both operations (filtering and sampling) are done at the same time. The Gaussian kernel is computed centered on the coordinates of the required sample. In this way, when applied, it gives directly the result of convolving the image with the kernel and interpolated to that particular position.<p>
A fast algorithm is done using the separability of the Gaussian kernel. Applying the 2D Gaussian kernel is equivalent to applying first a horizontal 1D Gaussian kernel and then a vertical 1D Gaussian kernel (or the other way round). The reason is that <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x,y) = G(x) * G(y) \]" src="form_1.png">
<p>
 where <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}. \]" src="form_2.png">
<p>
 The algorithm first apply a combined Gaussian kernel and sampling in the x axis, and then the combined Gaussian kernel and sampling in the y axis. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00511">511</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8h-source.html#l00059">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l00387">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00194">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00448">gaussian_kernel()</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00398">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00206">new_ntuple_list()</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, <a class="el" href="lsd_8h-source.html#l00060">ntuple_list_s::values</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00513 {
00514   <a class="code" href="structimage__double__s.html">image_double</a> aux,out;
00515   <a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel;
00516   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N,M,h,n,x,y,i;
00517   <span class="keywordtype">int</span> xc,yc,j,double_x_size,double_y_size;
00518   <span class="keywordtype">double</span> sigma,xx,yy,sum,prec;
00519 
00520   <span class="comment">/* check parameters */</span>
00521   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00522     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: invalid image."</span>);
00523   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: 'scale' must be positive."</span>);
00524   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 )
00525     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: 'sigma_scale' must be positive."</span>);
00526 
00527   <span class="comment">/* get memory for images */</span>
00528   <span class="keywordflow">if</span>( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX ||
00529       in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX )
00530     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: the output image size exceeds the handled size."</span>);
00531   N = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) floor( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale );
00532   M = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) floor( in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale );
00533   aux = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(N,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00534   out = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(N,M);
00535 
00536   <span class="comment">/* sigma, kernel size and memory for the kernel */</span>
00537   sigma = scale &lt; 1.0 ? sigma_scale / scale : sigma_scale;
00538   <span class="comment">/*</span>
00539 <span class="comment">     The size of the kernel is selected to guarantee that the</span>
00540 <span class="comment">     the first discarded term is at least 10^prec times smaller</span>
00541 <span class="comment">     than the central value. For that, h should be larger than x, with</span>
00542 <span class="comment">       e^(-x^2/2sigma^2) = 1/10^prec.</span>
00543 <span class="comment">     Then,</span>
00544 <span class="comment">       x = sigma * sqrt( 2 * prec * ln(10) ).</span>
00545 <span class="comment">   */</span>
00546   prec = 3.0;
00547   h = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( sigma * sqrt( 2.0 * prec * log(10.0) ) );
00548   n = 1+2*h; <span class="comment">/* kernel size */</span>
00549   kernel = <a class="code" href="lsd_8c.html#a16">new_ntuple_list</a>(n);
00550 
00551   <span class="comment">/* auxiliary double image size variables */</span>
00552   double_x_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>);
00553   double_y_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00554 
00555   <span class="comment">/* First subsampling: x axis */</span>
00556   <span class="keywordflow">for</span>(x=0;x&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00557     {
00558       <span class="comment">/*</span>
00559 <span class="comment">         x   is the coordinate in the new image.</span>
00560 <span class="comment">         xx  is the corresponding x-value in the original size image.</span>
00561 <span class="comment">         xc  is the integer value, the pixel coordinate of xx.</span>
00562 <span class="comment">       */</span>
00563       xx = (<span class="keywordtype">double</span>) x / scale;
00564       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00565 <span class="comment">         so the pixel with xc=0 get the values of xx from -0.5 to 0.5 */</span>
00566       xc = (<span class="keywordtype">int</span>) floor( xx + 0.5 );
00567       <a class="code" href="lsd_8c.html#a28">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + xx - (<span class="keywordtype">double</span>) xc );
00568       <span class="comment">/* the kernel must be computed for each x because the fine</span>
00569 <span class="comment">         offset xx-xc is different in each case */</span>
00570 
00571       <span class="keywordflow">for</span>(y=0;y&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00572         {
00573           sum = 0.0;
00574           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00575             {
00576               j = xc - h + i;
00577 
00578               <span class="comment">/* symmetry boundary condition */</span>
00579               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_x_size;
00580               <span class="keywordflow">while</span>( j &gt;= double_x_size ) j -= double_x_size;
00581               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ) j = double_x_size-1-j;
00582 
00583               sum += in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ j + y * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00584             }
00585           aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00586         }
00587     }
00588 
00589   <span class="comment">/* Second subsampling: y axis */</span>
00590   <span class="keywordflow">for</span>(y=0;y&lt;out-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00591     {
00592       <span class="comment">/*</span>
00593 <span class="comment">         y   is the coordinate in the new image.</span>
00594 <span class="comment">         yy  is the corresponding x-value in the original size image.</span>
00595 <span class="comment">         yc  is the integer value, the pixel coordinate of xx.</span>
00596 <span class="comment">       */</span>
00597       yy = (<span class="keywordtype">double</span>) y / scale;
00598       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00599 <span class="comment">         so the pixel with yc=0 get the values of yy from -0.5 to 0.5 */</span>
00600       yc = (<span class="keywordtype">int</span>) floor( yy + 0.5 );
00601       <a class="code" href="lsd_8c.html#a28">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + yy - (<span class="keywordtype">double</span>) yc );
00602       <span class="comment">/* the kernel must be computed for each y because the fine</span>
00603 <span class="comment">         offset yy-yc is different in each case */</span>
00604 
00605       <span class="keywordflow">for</span>(x=0;x&lt;out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00606         {
00607           sum = 0.0;
00608           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00609             {
00610               j = yc - h + i;
00611 
00612               <span class="comment">/* symmetry boundary condition */</span>
00613               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_y_size;
00614               <span class="keywordflow">while</span>( j &gt;= double_y_size ) j -= double_y_size;
00615               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> ) j = double_y_size-1-j;
00616 
00617               sum += aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + j * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00618             }
00619           out-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00620         }
00621     }
00622 
00623   <span class="comment">/* free memory */</span>
00624   <a class="code" href="lsd_8c.html#a15">free_ntuple_list</a>(kernel);
00625   <a class="code" href="lsd_8c.html#a25">free_image_double</a>(aux);
00626 
00627   <span class="keywordflow">return</span> out;
00628 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a29_cgraph.png" border="0" usemap="#lsd_8c_a29_cgraph_map" alt=""></center>
<map name="lsd_8c_a29_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="560,197,610,224" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="374,96,510,122" alt="">
<area href="lsd_8c.html#a15" shape="rect" coords="386,146,498,173" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="197,197,314,224" alt="">
<area href="lsd_8c.html#a26" shape="rect" coords="188,260,324,286" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="198,336,313,362" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="376,248,509,274" alt="">
</map>
<a class="anchor" name="a45" doxytag="lsd.c::get_theta" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double get_theta </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute region's angle as the principal inertia axis of the region. 
<p>
The following is the region inertia matrix A: <p class=formulaDsp>
<img class=formulaDsp alt="\[ A = \left(\begin{array}{cc} Ixx &amp; Ixy \\ Ixy &amp; Iyy \\ \end{array}\right) \]" src="form_10.png">
<p>
 where<p>
Ixx = sum_i G(i).(y_i - cx)^2<p>
Iyy = sum_i G(i).(x_i - cy)^2<p>
Ixy = - sum_i G(i).(x_i - cx).(y_i - cy)<p>
and<ul>
<li>G(i) is the gradient norm at pixel i, used as pixel's weight.</li><li>x_i and y_i are the coordinates of pixel i.</li><li>cx and cy are the coordinates of the center of th region.</li></ul>
<p>
lambda1 and lambda2 are the eigenvalues of matrix A, with lambda1 &gt;= lambda2. They are found by solving the characteristic polynomial:<p>
det( lambda I - A) = 0<p>
that gives:<p>
lambda1 = ( Ixx + Iyy + sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2<p>
lambda2 = ( Ixx + Iyy - sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2<p>
To get the line segment direction we want to get the angle the eigenvector assotiated to the smaller eigenvalue. We have to solve a,b in:<p>
a.Ixx + b.Ixy = a.lambda2<p>
a.Ixy + b.Iyy = b.lambda2<p>
We want the angle theta = atan(b/a). It can be computed with any of the two equations:<p>
theta = atan( (lambda2-Ixx) / Ixy )<p>
or<p>
theta = atan( Ixy / (lambda2-Iyy) )<p>
When |Ixx| &gt; |Iyy| we use the first, otherwise the second (just to get better numeric precision). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01456">1456</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00819">angle_diff()</a>, <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00155">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00085">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00123">point::x</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00123">point::y</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01499">region2rect()</a>.
<p>
<div class="fragment"><pre>01458 {
01459   <span class="keywordtype">double</span> lambda,theta,weight;
01460   <span class="keywordtype">double</span> Ixx = 0.0;
01461   <span class="keywordtype">double</span> Iyy = 0.0;
01462   <span class="keywordtype">double</span> Ixy = 0.0;
01463   <span class="keywordtype">int</span> i;
01464 
01465   <span class="comment">/* check parameters */</span>
01466   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: invalid region."</span>);
01467   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: region size &lt;= 1."</span>);
01468   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01469     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: invalid 'modgrad'."</span>);
01470   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: 'prec' must be positive."</span>);
01471 
01472   <span class="comment">/* compute inertia matrix */</span>
01473   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01474     {
01475       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01476       Ixx += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01477       Iyy += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * weight;
01478       Ixy -= ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01479     }
01480   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(Ixx,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a13">double_equal</a>(Iyy,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a13">double_equal</a>(Ixy,0.0) )
01481     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: null inertia matrix."</span>);
01482 
01483   <span class="comment">/* compute smallest eigenvalue */</span>
01484   lambda = 0.5 * ( Ixx + Iyy - sqrt( (Ixx-Iyy)*(Ixx-Iyy) + 4.0*Ixy*Ixy ) );
01485 
01486   <span class="comment">/* compute angle */</span>
01487   theta = fabs(Ixx)&gt;fabs(Iyy) ? atan2(lambda-Ixx,Ixy) : atan2(Ixy,lambda-Iyy);
01488 
01489   <span class="comment">/* The previous procedure don't cares about orientation,</span>
01490 <span class="comment">     so it could be wrong by 180 degrees. Here is corrected if necessary. */</span>
01491   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a32">angle_diff</a>(theta,reg_angle) &gt; prec ) theta += <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01492 
01493   <span class="keywordflow">return</span> theta;
01494 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a45_cgraph.png" border="0" usemap="#lsd_8c_a45_cgraph_map" alt=""></center>
<map name="lsd_8c_a45_cgraph_map">
<area href="lsd_8c.html#a32" shape="rect" coords="145,8,225,34" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="134,58,235,85" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="159,109,210,136" alt="">
</map>
<a class="anchor" name="a39" doxytag="lsd.c::inter_hi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double inter_hi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger of 'y1' and 'y2'. 
<p>
The following restrictions are required:<ul>
<li>x1 &lt;= x2</li><li>x1 &lt;= x</li><li>x &lt;= x2 </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01187">1187</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00155">double_equal()</a>, and <a class="el" href="lsd_8c-source.html#l00133">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01229">ri_inc()</a>.
<p>
<div class="fragment"><pre>01188 {
01189   <span class="comment">/* check parameters */</span>
01190   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01191     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"inter_hi: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01192 
01193   <span class="comment">/* interpolation */</span>
01194   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y2;
01195   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y1;
01196   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01197 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a39_cgraph.png" border="0" usemap="#lsd_8c_a39_cgraph_map" alt=""></center>
<map name="lsd_8c_a39_cgraph_map">
<area href="lsd_8c.html#a13" shape="rect" coords="124,7,225,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="149,58,200,85" alt="">
</map>
<a class="anchor" name="a38" doxytag="lsd.c::inter_low" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double inter_low </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'. 
<p>
The following restrictions are required:<ul>
<li>x1 &lt;= x2</li><li>x1 &lt;= x</li><li>x &lt;= x2 </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01165">1165</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00155">double_equal()</a>, and <a class="el" href="lsd_8c-source.html#l00133">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01229">ri_inc()</a>.
<p>
<div class="fragment"><pre>01166 {
01167   <span class="comment">/* check parameters */</span>
01168   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01169     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"inter_low: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01170 
01171   <span class="comment">/* interpolation */</span>
01172   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y1;
01173   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y2;
01174   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01175 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a38_cgraph.png" border="0" usemap="#lsd_8c_a38_cgraph_map" alt=""></center>
<map name="lsd_8c_a38_cgraph_map">
<area href="lsd_8c.html#a13" shape="rect" coords="134,7,235,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="159,58,210,85" alt="">
</map>
<a class="anchor" name="a31" doxytag="lsd.c::isaligned" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int isaligned </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>theta</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Is point (x,y) aligned to angle theta, up to precision 'prec'? 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00781">781</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l00089">FALSE</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00103">M_2__PI</a>, <a class="el" href="lsd_8c-source.html#l00100">M_3_2_PI</a>, <a class="el" href="lsd_8c-source.html#l00097">NOTDEF</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01592">region_grow()</a>.
<p>
<div class="fragment"><pre>00783 {
00784   <span class="keywordtype">double</span> a;
00785 
00786   <span class="comment">/* check parameters */</span>
00787   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00788     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"isaligned: invalid image 'angles'."</span>);
00789   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
00790     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"isaligned: (x,y) out of the image."</span>);
00791   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"isaligned: 'prec' must be positive."</span>);
00792 
00793   <span class="comment">/* angle at pixel (x,y) */</span>
00794   a = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
00795 
00796   <span class="comment">/* pixels whose level-line angle is not defined</span>
00797 <span class="comment">     are considered as NON-aligned */</span>
00798   <span class="keywordflow">if</span>( a == <a class="code" href="lsd_8c.html#a4">NOTDEF</a> ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;  <span class="comment">/* there is no need to call the function</span>
00799 <span class="comment">                                      'double_equal' here because there is</span>
00800 <span class="comment">                                      no risk of problems related to the</span>
00801 <span class="comment">                                      comparison doubles, we are only</span>
00802 <span class="comment">                                      interested in the exact NOTDEF value */</span>
00803 
00804   <span class="comment">/* it is assumed that 'theta' and 'a' are in the range [-pi,pi] */</span>
00805   theta -= a;
00806   <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00807   <span class="keywordflow">if</span>( theta &gt; <a class="code" href="lsd_8c.html#a5">M_3_2_PI</a> )
00808     {
00809       theta -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00810       <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00811     }
00812 
00813   <span class="keywordflow">return</span> theta &lt; prec;
00814 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a31_cgraph.png" border="0" usemap="#lsd_8c_a31_cgraph_map" alt=""></center>
<map name="lsd_8c_a31_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="130,8,181,34" alt="">
</map>
<a class="anchor" name="a51" doxytag="lsd.c::LineSegmentDetection" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structntuple__list__s.html">ntuple_list</a> LineSegmentDetection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>quant</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>ang_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>eps</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>max_grad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__int__s.html">image_int</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Full Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>image</em>&nbsp;</td><td>Input image.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different than 1.0, LSD will scale the image by Gaussian filtering. Example: is scale=0.8, the input image will be subsampled to 80% of its size, and then the line segment detector will be applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>sigma_scale</em>&nbsp;</td><td>When scale!=1.0, the sigma of the Gaussian filter is: sigma = sigma_scale / scale, if scale &lt; 1.0 sigma = sigma_scale, if scale &gt;= 1.0 Suggested value: 0.6</td></tr>
    <tr><td valign=top><em>quant</em>&nbsp;</td><td>Bound to the quantization error on the gradient norm. Example: if gray level is quantized to integer steps, the gradient (computed by finite differences) error due to quantization will be bounded by 2.0, as the worst case is when the error are 1 and -1, that gives an error of 2.0. Suggested value: 2.0</td></tr>
    <tr><td valign=top><em>ang_th</em>&nbsp;</td><td>Gradient angle tolerance in the region growing algorithm, in degrees. Suggested value: 22.5</td></tr>
    <tr><td valign=top><em>eps</em>&nbsp;</td><td>Detection threshold, -log10(NFA). The bigger, the more strict the detector is, and will result in less detections. (Note that the 'minus sign' makes that this behavior is opposite to the one of NFA.) The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1.0 corresponds to 10 mean false alarms</li><li>0.0 corresponds to 1 mean false alarm</li><li>1.0 corresponds to 0.1 mean false alarms</li><li>2.0 corresponds to 0.01 mean false alarms</li></ul>
Suggested value: 0.0</td></tr>
    <tr><td valign=top><em>density_th</em>&nbsp;</td><td>Minimal proportion of region points in a rectangle. Suggested value: 0.7</td></tr>
    <tr><td valign=top><em>n_bins</em>&nbsp;</td><td>Number of bins used in the pseudo-ordering of gradient modulus. Suggested value: 1024</td></tr>
    <tr><td valign=top><em>max_grad</em>&nbsp;</td><td>Gradient modulus in the highest bin. For example, for images with integer gray levels in [0,255], the maximum possible gradient value is 255.0. Suggested value: 255.0</td></tr>
    <tr><td valign=top><em>region</em>&nbsp;</td><td>Optional output: an int image where the pixels used in some line support region are marked. Unused pixels have the value '0' while the used ones have the number of the line segment, numbered 1,2,3,... If desired, a non NULL pointer to an image_int should be used. The resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 5-tuple list, where each 5-tuple corresponds to a detected line segment. The five values are:<ul>
<li>x1,y1,x2,y2,width</li></ul>
for a line segment from (x1,y1) to (x2,y2) and a width 'width'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01913">1913</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00250">add_5tuple()</a>, <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l00280">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00387">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>, <a class="el" href="lsd_8h.html#a1">image_char</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8h.html#a2">image_int</a>, <a class="el" href="lsd_8c-source.html#l00652">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00085">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00316">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00371">new_image_int_ini()</a>, <a class="el" href="lsd_8c-source.html#l00206">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00097">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00106">NOTUSED</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l01644">rect_improve()</a>, <a class="el" href="lsd_8c-source.html#l01835">refine()</a>, <a class="el" href="lsd_8c-source.html#l01499">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01592">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8h-source.html#l00083">image_char_s::xsize</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02053">lsd_scale()</a>.
<p>
<div class="fragment"><pre>01918 {
01919   <a class="code" href="structntuple__list__s.html">ntuple_list</a> out = <a class="code" href="lsd_8c.html#a16">new_ntuple_list</a>(5);
01920   <a class="code" href="structimage__double__s.html">image_double</a> scaled_image,angles,modgrad;
01921   <a class="code" href="structimage__char__s.html">image_char</a> used;
01922   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list_p;
01923   <span class="keywordtype">void</span> * mem_p;
01924   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> rec;
01925   <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> * reg;
01926   <span class="keywordtype">int</span> reg_size,min_reg_size,i;
01927   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,ysize;
01928   <span class="keywordtype">double</span> rho,reg_angle,prec,p,log_nfa,logNT;
01929   <span class="keywordtype">int</span> ls_count = 0;                   <span class="comment">/* line segments are numbered 1,2,3,... */</span>
01930 
01931 
01932   <span class="comment">/* check parameters */</span>
01933   <span class="keywordflow">if</span>( image==NULL || image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>==NULL || image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>==0 || image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>==0 )
01934     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"invalid image input."</span>);
01935   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'scale' value must be positive."</span>);
01936   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'sigma_scale' value must be positive."</span>);
01937   <span class="keywordflow">if</span>( quant &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'quant' value must be positive."</span>);
01938   <span class="keywordflow">if</span>( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )
01939     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'ang_th' value must be in the range (0,180)."</span>);
01940   <span class="keywordflow">if</span>( density_th &lt; 0.0 || density_th &gt; 1.0 )
01941     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'density_th' value must be in the range [0,1]."</span>);
01942   <span class="keywordflow">if</span>( n_bins &lt;= 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'n_bins' value must be positive."</span>);
01943   <span class="keywordflow">if</span>( max_grad &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'max_grad' value must be positive."</span>);
01944 
01945 
01946   <span class="comment">/* angle tolerance */</span>
01947   prec = <a class="code" href="lsd_8c.html#a1">M_PI</a> * ang_th / 180.0;
01948   p = ang_th / 180.0;
01949   rho = quant / sin(prec); <span class="comment">/* gradient magnitude threshold */</span>
01950 
01951 
01952   <span class="comment">/* scale image (if necessary) and compute angle at each pixel */</span>
01953   <span class="keywordflow">if</span>( scale != 1.0 )
01954     {
01955       scaled_image = <a class="code" href="lsd_8c.html#a29">gaussian_sampler</a>( image, scale, sigma_scale );
01956       angles = <a class="code" href="lsd_8c.html#a30">ll_angle</a>( scaled_image, rho, &amp;list_p, &amp;mem_p,
01957                          &amp;modgrad, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins, max_grad );
01958       <a class="code" href="lsd_8c.html#a25">free_image_double</a>(scaled_image);
01959     }
01960   <span class="keywordflow">else</span>
01961     angles = <a class="code" href="lsd_8c.html#a30">ll_angle</a>( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,
01962                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins, max_grad );
01963   xsize = angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
01964   ysize = angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
01965   logNT = 5.0 * ( log10( (<span class="keywordtype">double</span>) xsize ) + log10( (<span class="keywordtype">double</span>) ysize ) ) / 2.0;
01966   min_reg_size = (<span class="keywordtype">int</span>) (-logNT/log10(p)); <span class="comment">/* minimal number of points in region</span>
01967 <span class="comment">                                             that can give a meaningful event */</span>
01968 
01969 
01970   <span class="comment">/* initialize some structures */</span>
01971   <span class="keywordflow">if</span>( region != NULL ) <span class="comment">/* image to output pixel region number, if asked */</span>
01972     *region = <a class="code" href="lsd_8c.html#a24">new_image_int_ini</a>(angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>,0);
01973   used = <a class="code" href="lsd_8c.html#a21">new_image_char_ini</a>(xsize,ysize,NOTUSED);
01974   reg = (<span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a>) );
01975   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory!"</span>);
01976 
01977 
01978   <span class="comment">/* search for line segments */</span>
01979   <span class="keywordflow">for</span>(; list_p != NULL; list_p = list_p-&gt;next )
01980     <span class="keywordflow">if</span>( used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] == <a class="code" href="lsd_8c.html#a7">NOTUSED</a> &amp;&amp;
01981         angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] != <a class="code" href="lsd_8c.html#a4">NOTDEF</a> )
01982        <span class="comment">/* there is no risk of double comparison problems here</span>
01983 <span class="comment">          because we are only interested in the exact NOTDEF value */</span>
01984       {
01985         <span class="comment">/* find the region of connected point and ~equal angle */</span>
01986         <a class="code" href="lsd_8c.html#a47">region_grow</a>( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,
01987                      &amp;reg_angle, used, prec );
01988 
01989         <span class="comment">/* reject small regions */</span>
01990         <span class="keywordflow">if</span>( reg_size &lt; min_reg_size ) <span class="keywordflow">continue</span>;
01991 
01992         <span class="comment">/* construct rectangular approximation for the region */</span>
01993         <a class="code" href="lsd_8c.html#a46">region2rect</a>(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);
01994 
01995         <span class="comment">/* Check if the rectangle exceeds the minimal density of</span>
01996 <span class="comment">           region points. If not, try to improve the region.</span>
01997 <span class="comment">           The rectangle will be rejected if the final one does</span>
01998 <span class="comment">           not fulfill the minimal density condition.</span>
01999 <span class="comment">           This is an addition to the original LSD algorithm published in</span>
02000 <span class="comment">           "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
02001 <span class="comment">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</span>
02002 <span class="comment">           The original algorithm is obtained with density_th = 0.0.</span>
02003 <span class="comment">         */</span>
02004         <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a50">refine</a>( reg, &amp;reg_size, modgrad, reg_angle,
02005                      prec, p, &amp;rec, used, angles, density_th ) ) <span class="keywordflow">continue</span>;
02006 
02007         <span class="comment">/* compute NFA value */</span>
02008         log_nfa = <a class="code" href="lsd_8c.html#a48">rect_improve</a>(&amp;rec,angles,logNT,eps);
02009         <span class="keywordflow">if</span>( log_nfa &lt;= eps ) <span class="keywordflow">continue</span>;
02010 
02011         <span class="comment">/* A New Line Segment was found! */</span>
02012         ++ls_count;  <span class="comment">/* increase line segment counter */</span>
02013 
02014         <span class="comment">/*</span>
02015 <span class="comment">           The gradient was computed with a 2x2 mask, its value corresponds to</span>
02016 <span class="comment">           points with an offset of (0.5,0.5), that should be added to output.</span>
02017 <span class="comment">           The coordinates origin is at the center of pixel (0,0).</span>
02018 <span class="comment">         */</span>
02019         rec.<a class="code" href="structrect.html#o0">x1</a> += 0.5; rec.<a class="code" href="structrect.html#o1">y1</a> += 0.5;
02020         rec.<a class="code" href="structrect.html#o2">x2</a> += 0.5; rec.<a class="code" href="structrect.html#o3">y2</a> += 0.5;
02021 
02022         <span class="comment">/* scale the result values if a subsampling was performed */</span>
02023         <span class="keywordflow">if</span>( scale != 1.0 )
02024           {
02025             rec.<a class="code" href="structrect.html#o0">x1</a> /= scale; rec.<a class="code" href="structrect.html#o1">y1</a> /= scale;
02026             rec.<a class="code" href="structrect.html#o2">x2</a> /= scale; rec.<a class="code" href="structrect.html#o3">y2</a> /= scale;
02027             rec.<a class="code" href="structrect.html#o4">width</a> /= scale;
02028           }
02029 
02030         <span class="comment">/* add line segment found to output */</span>
02031         <a class="code" href="lsd_8c.html#a18">add_5tuple</a>(out, rec.<a class="code" href="structrect.html#o0">x1</a>, rec.<a class="code" href="structrect.html#o1">y1</a>, rec.<a class="code" href="structrect.html#o2">x2</a>, rec.<a class="code" href="structrect.html#o3">y2</a>, rec.<a class="code" href="structrect.html#o4">width</a>);
02032 
02033         <span class="comment">/* add region number to 'region' image if needed */</span>
02034         <span class="keywordflow">if</span>( region != NULL )
02035           <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
02036             (*region)-&gt;data[reg[i].x+reg[i].y*(*region)-&gt;xsize] = ls_count;
02037       }
02038 
02039 
02040   <span class="comment">/* free memory */</span>
02041   <a class="code" href="lsd_8c.html#a25">free_image_double</a>(angles);
02042   <a class="code" href="lsd_8c.html#a25">free_image_double</a>(modgrad);
02043   <a class="code" href="lsd_8c.html#a19">free_image_char</a>(used);
02044   free( (<span class="keywordtype">void</span> *) reg );
02045   free( (<span class="keywordtype">void</span> *) mem_p );
02046 
02047   <span class="keywordflow">return</span> out;
02048 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a51_cgraph.png" border="0" usemap="#lsd_8c_a51_cgraph_map" alt=""></center>
<map name="lsd_8c_a51_cgraph_map">
<area href="lsd_8c.html#a18" shape="rect" coords="433,8,521,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="594,261,645,288" alt="">
<area href="lsd_8c.html#a19" shape="rect" coords="415,109,538,136" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="409,160,545,186" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="221,210,351,237" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="419,261,534,288" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="253,312,319,338" alt="">
<area href="lsd_8c.html#a21" shape="rect" coords="214,362,358,389" alt="">
<area href="lsd_8c.html#a24" shape="rect" coords="219,413,353,440" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="237,464,335,490" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="258,565,314,592" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="433,489,521,516" alt="">
<area href="lsd_8c.html#a47" shape="rect" coords="430,590,523,617" alt="">
</map>
<a class="anchor" name="a30" doxytag="lsd.c::ll_angle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> ll_angle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structcoorlist.html">coorlist</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>list_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>mem_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>max_grad</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the direction of the level line of 'in' at each point. 
<p>
The result is:<ul>
<li>an image_double with the angle at each pixel, or NOTDEF if not defined.</li><li>the image_double 'modgrad' (a pointer is passed as argument) with the gradient magnitude at each point.</li><li>a list of pixels 'list_p' roughly ordered by decreasing gradient magnitude. (The order is made by classifying points into bins by gradient magnitude. The parameters 'n_bins' and 'max_grad' specify the number of bins and the gradient modulus at the highest bin. The pixels in the list would be in decreasing gradient magnitude, up to a precision of the size of the bins.)</li><li>a pointer 'mem_p' to the memory used by 'list_p' to be able to free the memory when it is not used anymore. </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00652">652</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00398">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00097">NOTDEF</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00656 {
00657   <a class="code" href="structimage__double__s.html">image_double</a> g;
00658   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,p,x,y,adr,i;
00659   <span class="keywordtype">double</span> com1,com2,gx,gy,norm,norm2;
00660   <span class="comment">/* the rest of the variables are used for pseudo-ordering</span>
00661 <span class="comment">     the gradient magnitude values */</span>
00662   <span class="keywordtype">int</span> list_count = 0;
00663   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list;
00664   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_s; <span class="comment">/* array of pointers to start of bin list */</span>
00665   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_e; <span class="comment">/* array of pointers to end of bin list */</span>
00666   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * start;
00667   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * end;
00668 
00669   <span class="comment">/* check parameters */</span>
00670   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00671     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: invalid image."</span>);
00672   <span class="keywordflow">if</span>( threshold &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: 'threshold' must be positive."</span>);
00673   <span class="keywordflow">if</span>( list_p == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'list_p'."</span>);
00674   <span class="keywordflow">if</span>( mem_p == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'mem_p'."</span>);
00675   <span class="keywordflow">if</span>( modgrad == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'modgrad'."</span>);
00676   <span class="keywordflow">if</span>( n_bins == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: 'n_bins' must be positive."</span>);
00677   <span class="keywordflow">if</span>( max_grad &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: 'max_grad' must be positive."</span>);
00678 
00679   <span class="comment">/* image size shortcuts */</span>
00680   n = in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
00681   p = in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
00682 
00683   <span class="comment">/* allocate output image */</span>
00684   g = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00685 
00686   <span class="comment">/* get memory for the image of gradient modulus */</span>
00687   *modgrad = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00688 
00689   <span class="comment">/* get memory for "ordered" list of pixels */</span>
00690   list = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> *) calloc( (size_t) (n*p), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a>) );
00691   *mem_p = (<span class="keywordtype">void</span> *) list;
00692   range_l_s = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00693                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00694   range_l_e = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00695                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00696   <span class="keywordflow">if</span>( list == NULL || range_l_s == NULL || range_l_e == NULL )
00697     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00698   <span class="keywordflow">for</span>(i=0;i&lt;n_bins;i++) range_l_s[i] = range_l_e[i] = NULL;
00699 
00700   <span class="comment">/* 'undefined' on the down and right boundaries */</span>
00701   <span class="keywordflow">for</span>(x=0;x&lt;p;x++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[(n-1)*p+x] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00702   <span class="keywordflow">for</span>(y=0;y&lt;n;y++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[p*y+p-1]   = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00703 
00704   <span class="comment">/* compute gradient on the remaining pixels */</span>
00705   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00706     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00707       {
00708         adr = y*p+x;
00709 
00710         <span class="comment">/*</span>
00711 <span class="comment">           Norm 2 computation using 2x2 pixel window:</span>
00712 <span class="comment">             A B</span>
00713 <span class="comment">             C D</span>
00714 <span class="comment">           and</span>
00715 <span class="comment">             com1 = D-A,  com2 = B-C.</span>
00716 <span class="comment">           Then</span>
00717 <span class="comment">             gx = B+D - (A+C)   horizontal difference</span>
00718 <span class="comment">             gy = C+D - (A+B)   vertical difference</span>
00719 <span class="comment">           com1 and com2 are just to avoid 2 additions.</span>
00720 <span class="comment">         */</span>
00721         com1 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p+1] - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr];
00722         com2 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+1]   - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p];
00723 
00724         gx = com1+com2; <span class="comment">/* gradient x component */</span>
00725         gy = com1-com2; <span class="comment">/* gradient y component */</span>
00726         norm2 = gx*gx+gy*gy;
00727         norm = sqrt( norm2 / 4.0 ); <span class="comment">/* gradient norm */</span>
00728 
00729         (*modgrad)-&gt;data[adr] = norm; <span class="comment">/* store gradient norm */</span>
00730 
00731         <span class="keywordflow">if</span>( norm &lt;= threshold ) <span class="comment">/* norm too small, gradient no defined */</span>
00732           g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>; <span class="comment">/* gradient angle not defined */</span>
00733         <span class="keywordflow">else</span>
00734           {
00735             <span class="comment">/* gradient angle computation */</span>
00736             g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = atan2(gx,-gy);
00737 
00738             <span class="comment">/* store the point in the right bin according to its norm */</span>
00739             i = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (norm * (<span class="keywordtype">double</span>) n_bins / max_grad);
00740             <span class="keywordflow">if</span>( i &gt;= n_bins ) i = n_bins-1;
00741             <span class="keywordflow">if</span>( range_l_e[i] == NULL )
00742               range_l_s[i] = range_l_e[i] = list+list_count++;
00743             <span class="keywordflow">else</span>
00744               {
00745                 range_l_e[i]-&gt;next = list+list_count;
00746                 range_l_e[i] = list+list_count++;
00747               }
00748             range_l_e[i]-&gt;x = (<span class="keywordtype">int</span>) x;
00749             range_l_e[i]-&gt;y = (<span class="keywordtype">int</span>) y;
00750             range_l_e[i]-&gt;next = NULL;
00751           }
00752       }
00753 
00754   <span class="comment">/* Make the list of pixels (almost) ordered by norm value.</span>
00755 <span class="comment">     It starts by the larger bin, so the list starts by the</span>
00756 <span class="comment">     pixels with higher gradient value. Pixels would be ordered</span>
00757 <span class="comment">     by norm value, up to a precision given by max_grad/n_bins.</span>
00758 <span class="comment">   */</span>
00759   <span class="keywordflow">for</span>(i=n_bins-1; i&gt;0 &amp;&amp; range_l_s[i]==NULL; i--);
00760   start = range_l_s[i];
00761   end = range_l_e[i];
00762   <span class="keywordflow">if</span>( start != NULL )
00763     <span class="keywordflow">for</span>(i--;i&gt;0; i--)
00764       <span class="keywordflow">if</span>( range_l_s[i] != NULL )
00765         {
00766           end-&gt;next = range_l_s[i];
00767           end = range_l_e[i];
00768         }
00769   *list_p = start;
00770 
00771   <span class="comment">/* free memory */</span>
00772   free( (<span class="keywordtype">void</span> *) range_l_s );
00773   free( (<span class="keywordtype">void</span> *) range_l_e );
00774 
00775   <span class="keywordflow">return</span> g;
00776 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a30_cgraph.png" border="0" usemap="#lsd_8c_a30_cgraph_map" alt=""></center>
<map name="lsd_8c_a30_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="312,33,362,59" alt="">
<area href="lsd_8c.html#a26" shape="rect" coords="126,58,262,85" alt="">
</map>
<a class="anchor" name="a34" doxytag="lsd.c::log_gamma_lanczos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double log_gamma_lanczos </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. 
<p>
See <a href="http://www.rskey.org/gamma.htm">http://www.rskey.org/gamma.htm</a><p>
The formula used is <p class=formulaDsp>
<img class=formulaDsp alt="\[ \Gamma(x) = \frac{ \sum_{n=0}^{N} q_n x^n }{ \Pi_{n=0}^{N} (x+n) } (x+5.5)^{x+0.5} e^{-(x+5.5)} \]" src="form_3.png">
<p>
 so <p class=formulaDsp>
<img class=formulaDsp alt="\[ \log\Gamma(x) = \log\left( \sum_{n=0}^{N} q_n x^n \right) + (x+0.5) \log(x+5.5) - (x+5.5) - \sum_{n=0}^{N} \log(x+n) \]" src="form_4.png">
<p>
 and q0 = 75122.6331530, q1 = 80916.6278952, q2 = 36308.2951477, q3 = 8687.24529705, q4 = 1168.92649479, q5 = 83.8676043424, q6 = 2.50662827511. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00868">868</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<div class="fragment"><pre>00869 {
00870   <span class="keyword">static</span> <span class="keywordtype">double</span> q[7] = { 75122.6331530, 80916.6278952, 36308.2951477,
00871                          8687.24529705, 1168.92649479, 83.8676043424,
00872                          2.50662827511 };
00873   <span class="keywordtype">double</span> a = (x+0.5) * log(x+5.5) - (x+5.5);
00874   <span class="keywordtype">double</span> b = 0.0;
00875   <span class="keywordtype">int</span> n;
00876 
00877   <span class="keywordflow">for</span>(n=0;n&lt;7;n++)
00878     {
00879       a -= log( x + (<span class="keywordtype">double</span>) n );
00880       b += q[n] * pow( x, (<span class="keywordtype">double</span>) n );
00881     }
00882   <span class="keywordflow">return</span> a + log(b);
00883 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="lsd.c::log_gamma_windschitl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double log_gamma_windschitl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. 
<p>
See <a href="http://www.rskey.org/gamma.htm">http://www.rskey.org/gamma.htm</a><p>
The formula used is <p class=formulaDsp>
<img class=formulaDsp alt="\[ \Gamma(x) = \sqrt{\frac{2\pi}{x}} \left( \frac{x}{e} \sqrt{ x\sinh(1/x) + \frac{1}{810x^6} } \right)^x \]" src="form_5.png">
<p>
 so <p class=formulaDsp>
<img class=formulaDsp alt="\[ \log\Gamma(x) = 0.5\log(2\pi) + (x-0.5)\log(x) - x + 0.5x\log\left( x\sinh(1/x) + \frac{1}{810x^6} \right). \]" src="form_6.png">
<p>
 This formula is a good approximation when x &gt; 15. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00902">902</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<div class="fragment"><pre>00903 {
00904   <span class="keywordflow">return</span> 0.918938533204673 + (x-0.5)*log(x) - x
00905          + 0.5*x*log( x*sinh(1/x) + 1/(810.0*pow(x,6.0)) );
00906 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="lsd.c::lsd" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structntuple__list__s.html">ntuple_list</a> lsd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>image</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>image</em>&nbsp;</td><td>Input image.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a 5-tuple list of detected line segments. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02077">2077</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l02053">lsd_scale()</a>, and <a class="el" href="lsd_8h.html#a0">ntuple_list</a>.
<p>
<div class="fragment"><pre>02078 {
02079   <span class="comment">/* LSD parameters */</span>
02080   <span class="keywordtype">double</span> scale = 0.8;       <span class="comment">/* Scale the image by Gaussian filter to 'scale'. */</span>
02081 
02082   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a52">lsd_scale</a>(image,scale);
02083 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a53_cgraph.png" border="0" usemap="#lsd_8c_a53_cgraph_map" alt=""></center>
<map name="lsd_8c_a53_cgraph_map">
<area href="lsd_8c.html#a52" shape="rect" coords="96,312,173,338" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="221,312,378,338" alt="">
<area href="lsd_8c.html#a18" shape="rect" coords="646,8,734,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="808,261,858,288" alt="">
<area href="lsd_8c.html#a19" shape="rect" coords="629,109,752,136" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="622,160,758,186" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="434,210,565,237" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="633,261,748,288" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="466,312,533,338" alt="">
<area href="lsd_8c.html#a21" shape="rect" coords="428,362,572,389" alt="">
<area href="lsd_8c.html#a24" shape="rect" coords="433,413,566,440" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="450,464,549,490" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="472,565,528,592" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="646,489,734,516" alt="">
<area href="lsd_8c.html#a47" shape="rect" coords="644,590,737,617" alt="">
</map>
<a class="anchor" name="a52" doxytag="lsd.c::lsd_scale" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structntuple__list__s.html">ntuple_list</a> lsd_scale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>image</em>&nbsp;</td><td>Input image.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different than 1.0, LSD will scale the image by Gaussian filtering. Example: is scale=0.8, the input image will be subsampled to 80% of its size, and then the line segment detector will be applied. Suggested value: 0.8</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a 5-tuple list of detected line segments. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02053">2053</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, and <a class="el" href="lsd_8h.html#a0">ntuple_list</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02077">lsd()</a>.
<p>
<div class="fragment"><pre>02054 {
02055   <span class="comment">/* LSD parameters */</span>
02056   <span class="keywordtype">double</span> sigma_scale = 0.6; <span class="comment">/* Sigma for Gaussian filter is computed as</span>
02057 <span class="comment">                                sigma = sigma_scale/scale.                    */</span>
02058   <span class="keywordtype">double</span> quant = 2.0;       <span class="comment">/* Bound to the quantization error on the</span>
02059 <span class="comment">                                gradient norm.                                */</span>
02060   <span class="keywordtype">double</span> ang_th = 22.5;     <span class="comment">/* Gradient angle tolerance in degrees.           */</span>
02061   <span class="keywordtype">double</span> eps = 0.0;         <span class="comment">/* Detection threshold, -log10(NFA).              */</span>
02062   <span class="keywordtype">double</span> density_th = 0.7;  <span class="comment">/* Minimal density of region points in rectangle. */</span>
02063   <span class="keywordtype">int</span> n_bins = 1024;        <span class="comment">/* Number of bins in pseudo-ordering of gradient</span>
02064 <span class="comment">                               modulus.                                       */</span>
02065   <span class="keywordtype">double</span> max_grad = 255.0;  <span class="comment">/* Gradient modulus in the highest bin. The</span>
02066 <span class="comment">                               default value corresponds to the highest</span>
02067 <span class="comment">                               gradient modulus on images with gray</span>
02068 <span class="comment">                               levels in [0,255].                             */</span>
02069 
02070   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a51">LineSegmentDetection</a>( image, scale, sigma_scale, quant, ang_th, eps,
02071                                density_th, n_bins, max_grad, NULL );
02072 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a52_cgraph.png" border="0" usemap="#lsd_8c_a52_cgraph_map" alt=""></center>
<map name="lsd_8c_a52_cgraph_map">
<area href="lsd_8c.html#a51" shape="rect" coords="133,312,290,338" alt="">
<area href="lsd_8c.html#a18" shape="rect" coords="558,8,646,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="720,261,770,288" alt="">
<area href="lsd_8c.html#a19" shape="rect" coords="541,109,664,136" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="534,160,670,186" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="346,210,477,237" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="545,261,660,288" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="378,312,445,338" alt="">
<area href="lsd_8c.html#a21" shape="rect" coords="340,362,484,389" alt="">
<area href="lsd_8c.html#a24" shape="rect" coords="345,413,478,440" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="362,464,461,490" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="384,565,440,592" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="558,489,646,516" alt="">
<area href="lsd_8c.html#a47" shape="rect" coords="556,590,649,617" alt="">
</map>
<a class="anchor" name="a20" doxytag="lsd.c::new_image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__char__s.html">image_char</a> new_image_char </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_char of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00291">291</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a1">image_char</a>, <a class="el" href="lsd_8h-source.html#l00083">image_char_s::xsize</a>, and <a class="el" href="lsd_8h-source.html#l00083">image_char_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00316">new_image_char_ini()</a>.
<p>
<div class="fragment"><pre>00292 {
00293   <a class="code" href="structimage__char__s.html">image_char</a> image;
00294 
00295   <span class="comment">/* check parameters */</span>
00296   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_char: invalid image size."</span>);
00297 
00298   <span class="comment">/* get memory */</span>
00299   image = (<a class="code" href="structimage__char__s.html">image_char</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__char__s.html">image_char_s</a>) );
00300   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00301   image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) calloc( (size_t) (xsize*ysize),
00302                                           <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) );
00303   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00304 
00305   <span class="comment">/* set image size */</span>
00306   image-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> = xsize;
00307   image-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> = ysize;
00308 
00309   <span class="keywordflow">return</span> image;
00310 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a20_cgraph.png" border="0" usemap="#lsd_8c_a20_cgraph_map" alt=""></center>
<map name="lsd_8c_a20_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="181,8,232,34" alt="">
</map>
<a class="anchor" name="a21" doxytag="lsd.c::new_image_char_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__char__s.html">image_char</a> new_image_char_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_char of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00316">316</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a1">image_char</a>, and <a class="el" href="lsd_8c-source.html#l00291">new_image_char()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00318 {
00319   <a class="code" href="structimage__char__s.html">image_char</a> image = <a class="code" href="lsd_8c.html#a20">new_image_char</a>(xsize,ysize); <span class="comment">/* create image */</span>
00320   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00321   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00322 
00323   <span class="comment">/* check parameters */</span>
00324   <span class="keywordflow">if</span>( image == NULL || image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00325     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_char_ini: invalid image."</span>);
00326 
00327   <span class="comment">/* initialize */</span>
00328   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[i] = fill_value;
00329 
00330   <span class="keywordflow">return</span> image;
00331 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a21_cgraph.png" border="0" usemap="#lsd_8c_a21_cgraph_map" alt=""></center>
<map name="lsd_8c_a21_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="376,33,426,59" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="204,58,326,85" alt="">
</map>
<a class="anchor" name="a26" doxytag="lsd.c::new_image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> new_image_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_double of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00398">398</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l00652">ll_angle()</a>, and <a class="el" href="lsd_8c-source.html#l00422">new_image_double_ini()</a>.
<p>
<div class="fragment"><pre>00399 {
00400   <a class="code" href="structimage__double__s.html">image_double</a> image;
00401 
00402   <span class="comment">/* check parameters */</span>
00403   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_double: invalid image size."</span>);
00404 
00405   <span class="comment">/* get memory */</span>
00406   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00407   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00408   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = (<span class="keywordtype">double</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00409   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00410 
00411   <span class="comment">/* set image size */</span>
00412   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00413   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00414 
00415   <span class="keywordflow">return</span> image;
00416 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a26_cgraph.png" border="0" usemap="#lsd_8c_a26_cgraph_map" alt=""></center>
<map name="lsd_8c_a26_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="194,8,245,34" alt="">
</map>
<a class="anchor" name="a27" doxytag="lsd.c::new_image_double_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> new_image_double_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_double of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00422">422</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, and <a class="el" href="lsd_8c-source.html#l00398">new_image_double()</a>.
<p>
<div class="fragment"><pre>00424 {
00425   <a class="code" href="structimage__double__s.html">image_double</a> image = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(xsize,ysize); <span class="comment">/* create image */</span>
00426   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00427   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00428 
00429   <span class="comment">/* initialize */</span>
00430   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[i] = fill_value;
00431 
00432   <span class="keywordflow">return</span> image;
00433 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a27_cgraph.png" border="0" usemap="#lsd_8c_a27_cgraph_map" alt=""></center>
<map name="lsd_8c_a27_cgraph_map">
<area href="lsd_8c.html#a26" shape="rect" coords="217,8,353,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="402,8,453,34" alt="">
</map>
<a class="anchor" name="a23" doxytag="lsd.c::new_image_int" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__int__s.html">image_int</a> new_image_int </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_int of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00347">347</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00102">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a2">image_int</a>, <a class="el" href="lsd_8h-source.html#l00103">image_int_s::xsize</a>, and <a class="el" href="lsd_8h-source.html#l00103">image_int_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00371">new_image_int_ini()</a>.
<p>
<div class="fragment"><pre>00348 {
00349   <a class="code" href="structimage__int__s.html">image_int</a> image;
00350 
00351   <span class="comment">/* check parameters */</span>
00352   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_int: invalid image size."</span>);
00353 
00354   <span class="comment">/* get memory */</span>
00355   image = (<a class="code" href="structimage__int__s.html">image_int</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__int__s.html">image_int_s</a>) );
00356   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00357   image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> = (<span class="keywordtype">int</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) );
00358   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00359 
00360   <span class="comment">/* set image size */</span>
00361   image-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> = xsize;
00362   image-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a> = ysize;
00363 
00364   <span class="keywordflow">return</span> image;
00365 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a23_cgraph.png" border="0" usemap="#lsd_8c_a23_cgraph_map" alt=""></center>
<map name="lsd_8c_a23_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="168,8,218,34" alt="">
</map>
<a class="anchor" name="a24" doxytag="lsd.c::new_image_int_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__int__s.html">image_int</a> new_image_int_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_int of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00371">371</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00102">image_int_s::data</a>, <a class="el" href="lsd_8h.html#a2">image_int</a>, and <a class="el" href="lsd_8c-source.html#l00347">new_image_int()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00373 {
00374   <a class="code" href="structimage__int__s.html">image_int</a> image = <a class="code" href="lsd_8c.html#a23">new_image_int</a>(xsize,ysize); <span class="comment">/* create image */</span>
00375   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00376   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00377 
00378   <span class="comment">/* initialize */</span>
00379   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[i] = fill_value;
00380 
00381   <span class="keywordflow">return</span> image;
00382 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a24_cgraph.png" border="0" usemap="#lsd_8c_a24_cgraph_map" alt=""></center>
<map name="lsd_8c_a24_cgraph_map">
<area href="lsd_8c.html#a23" shape="rect" coords="189,8,301,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="349,8,400,34" alt="">
</map>
<a class="anchor" name="a16" doxytag="lsd.c::new_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structntuple__list__s.html">ntuple_list</a> new_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dim</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an n-tuple list and allocate memory for one element. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dim</em>&nbsp;</td><td>the dimension (n) of the n-tuple. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00206">206</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00059">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h-source.html#l00058">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8h.html#a0">ntuple_list</a>, <a class="el" href="lsd_8h-source.html#l00057">ntuple_list_s::size</a>, and <a class="el" href="lsd_8h-source.html#l00060">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00511">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00207 {
00208   <a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple;
00209 
00210   <span class="comment">/* check parameters */</span>
00211   <span class="keywordflow">if</span>( dim == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_ntuple_list: 'dim' must be positive."</span>);
00212 
00213   <span class="comment">/* get memory for list structure */</span>
00214   n_tuple = (<a class="code" href="structntuple__list__s.html">ntuple_list</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structntuple__list__s.html">ntuple_list_s</a>) );
00215   <span class="keywordflow">if</span>( n_tuple == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00216 
00217   <span class="comment">/* initialize list */</span>
00218   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 0;
00219   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> = 1;
00220   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> = dim;
00221 
00222   <span class="comment">/* get memory for tuples */</span>
00223   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) malloc( dim*n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00224   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00225 
00226   <span class="keywordflow">return</span> n_tuple;
00227 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a16_cgraph.png" border="0" usemap="#lsd_8c_a16_cgraph_map" alt=""></center>
<map name="lsd_8c_a16_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="170,8,221,34" alt="">
</map>
<a class="anchor" name="a36" doxytag="lsd.c::nfa" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double nfa </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes -log10(NFA). 
<p>
NFA stands for Number of False Alarms: <p class=formulaDsp>
<img class=formulaDsp alt="\[ \mathrm{NFA} = NT \cdot B(n,k,p) \]" src="form_7.png">
<p>
<p>
<ul>
<li>NT - number of tests</li><li>B(n,k,p) - tail of binomial distribution with parameters n,k and p: <p class=formulaDsp>
<img class=formulaDsp alt="\[ B(n,k,p) = \sum_{j=k}^n \left(\begin{array}{c}n\\j\end{array}\right) p^{j} (1-p)^{n-j} \]" src="form_8.png">
<p>
</li></ul>
<p>
The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1 corresponds to 10 mean false alarms</li><li>0 corresponds to 1 mean false alarm</li><li>1 corresponds to 0.1 mean false alarms</li><li>2 corresponds to 0.01 mean false alarms</li><li>...</li></ul>
<p>
Used this way, the bigger the value, better the detection, and a logarithmic scale is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n,k,p</em>&nbsp;</td><td>binomial parameters. </td></tr>
    <tr><td valign=top><em>logNT</em>&nbsp;</td><td>logarithm of Number of Tests</td></tr>
  </table>
</dl>
The computation is based in the gamma function by the following relation: <p class=formulaDsp>
<img class=formulaDsp alt="\[ \left(\begin{array}{c}n\\k\end{array}\right) = \frac{ \Gamma(n+1) }{ \Gamma(k+1) \cdot \Gamma(n-k+1) }. \]" src="form_9.png">
<p>
 We use efficient algorithms to compute the logarithm of the gamma function.<p>
To make the computation faster, not all the sum is computed, part of the terms are neglected based on a bound to the error obtained (an error of 10% in the result is accepted). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00962">962</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00155">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l00913">log_gamma</a>, <a class="el" href="lsd_8c-source.html#l00080">M_LN10</a>, and <a class="el" href="lsd_8c-source.html#l00918">TABSIZE</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>.
<p>
<div class="fragment"><pre>00963 {
00964   <span class="keyword">static</span> <span class="keywordtype">double</span> inv[<a class="code" href="lsd_8c.html#a11">TABSIZE</a>];   <span class="comment">/* table to keep computed inverse values */</span>
00965   <span class="keywordtype">double</span> tolerance = 0.1;       <span class="comment">/* an error of 10% in the result is accepted */</span>
00966   <span class="keywordtype">double</span> log1term,term,bin_term,mult_term,bin_tail,err,p_term;
00967   <span class="keywordtype">int</span> i;
00968 
00969   <span class="comment">/* check parameters */</span>
00970   <span class="keywordflow">if</span>( n&lt;0 || k&lt;0 || k&gt;n || p&lt;=0.0 || p&gt;=1.0 )
00971     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"nfa: wrong n, k or p values."</span>);
00972 
00973   <span class="comment">/* trivial cases */</span>
00974   <span class="keywordflow">if</span>( n==0 || k==0 ) <span class="keywordflow">return</span> -logNT;
00975   <span class="keywordflow">if</span>( n==k ) <span class="keywordflow">return</span> -logNT - (<span class="keywordtype">double</span>) n * log10(p);
00976 
00977   <span class="comment">/* probability term */</span>
00978   p_term = p / (1.0-p);
00979 
00980   <span class="comment">/* compute the first term of the series */</span>
00981   <span class="comment">/*</span>
00982 <span class="comment">     binomial_tail(n,k,p) = sum_{i=k}^n bincoef(n,i) * p^i * (1-p)^{n-i}</span>
00983 <span class="comment">     where bincoef(n,i) are the binomial coefficients.</span>
00984 <span class="comment">     But</span>
00985 <span class="comment">       bincoef(n,k) = gamma(n+1) / ( gamma(k+1) * gamma(n-k+1) ).</span>
00986 <span class="comment">     We use this to compute the first term. Actually the log of it.</span>
00987 <span class="comment">   */</span>
00988   log1term = <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) n + 1.0 ) - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) k + 1.0 )
00989            - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) (n-k) + 1.0 )
00990            + (<span class="keywordtype">double</span>) k * log(p) + (<span class="keywordtype">double</span>) (n-k) * log(1.0-p);
00991   term = exp(log1term);
00992 
00993   <span class="comment">/* in some cases no more computations are needed */</span>
00994   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(term,0.0) )              <span class="comment">/* the first term is almost zero */</span>
00995     {
00996       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) k &gt; (<span class="keywordtype">double</span>) n * p )     <span class="comment">/* at begin or end of the tail?  */</span>
00997         <span class="keywordflow">return</span> -log1term / <a class="code" href="lsd_8c.html#a0">M_LN10</a> - logNT;  <span class="comment">/* end: use just the first term  */</span>
00998       <span class="keywordflow">else</span>
00999         <span class="keywordflow">return</span> -logNT;                      <span class="comment">/* begin: the tail is roughly 1  */</span>
01000     }
01001 
01002   <span class="comment">/* compute more terms if needed */</span>
01003   bin_tail = term;
01004   <span class="keywordflow">for</span>(i=k+1;i&lt;=n;i++)
01005     {
01006       <span class="comment">/*</span>
01007 <span class="comment">         As</span>
01008 <span class="comment">           term_i = bincoef(n,i) * p^i * (1-p)^(n-i)</span>
01009 <span class="comment">         and</span>
01010 <span class="comment">           bincoef(n,i)/bincoef(n,i-1) = n-1+1 / i,</span>
01011 <span class="comment">         then,</span>
01012 <span class="comment">           term_i / term_i-1 = (n-i+1)/i * p/(1-p)</span>
01013 <span class="comment">         and</span>
01014 <span class="comment">           term_i = term_i-1 * (n-i+1)/i * p/(1-p).</span>
01015 <span class="comment">         1/i is stored in a table as they are computed,</span>
01016 <span class="comment">         because divisions are expensive.</span>
01017 <span class="comment">         p/(1-p) is computed only once and stored in 'p_term'.</span>
01018 <span class="comment">       */</span>
01019       bin_term = (<span class="keywordtype">double</span>) (n-i+1) * ( i&lt;<a class="code" href="lsd_8c.html#a11">TABSIZE</a> ?
01020                    ( inv[i]!=0.0 ? inv[i] : ( inv[i] = 1.0 / (<span class="keywordtype">double</span>) i ) ) :
01021                    1.0 / (<span class="keywordtype">double</span>) i );
01022 
01023       mult_term = bin_term * p_term;
01024       term *= mult_term;
01025       bin_tail += term;
01026       <span class="keywordflow">if</span>(bin_term&lt;1.0)
01027         {
01028           <span class="comment">/* When bin_term&lt;1 then mult_term_j&lt;mult_term_i for j&gt;i.</span>
01029 <span class="comment">             Then, the error on the binomial tail when truncated at</span>
01030 <span class="comment">             the i term can be bounded by a geometric series of form</span>
01031 <span class="comment">             term_i * sum mult_term_i^j.                            */</span>
01032           err = term * ( ( 1.0 - pow( mult_term, (<span class="keywordtype">double</span>) (n-i+1) ) ) /
01033                          (1.0-mult_term) - 1.0 );
01034 
01035           <span class="comment">/* One wants an error at most of tolerance*final_result, or:</span>
01036 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT).</span>
01037 <span class="comment">             Now, the error that can be accepted on bin_tail is</span>
01038 <span class="comment">             given by tolerance*final_result divided by the derivative</span>
01039 <span class="comment">             of -log10(x) when x=bin_tail. that is:</span>
01040 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) / (1/bin_tail)</span>
01041 <span class="comment">             Finally, we truncate the tail if the error is less than:</span>
01042 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) * bin_tail        */</span>
01043           <span class="keywordflow">if</span>( err &lt; tolerance * fabs(-log10(bin_tail)-logNT) * bin_tail ) <span class="keywordflow">break</span>;
01044         }
01045     }
01046   <span class="keywordflow">return</span> -log10(bin_tail) - logNT;
01047 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a36_cgraph.png" border="0" usemap="#lsd_8c_a36_cgraph_map" alt=""></center>
<map name="lsd_8c_a36_cgraph_map">
<area href="lsd_8c.html#a13" shape="rect" coords="100,7,201,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="125,58,176,85" alt="">
</map>
<a class="anchor" name="a37" doxytag="lsd.c::rect_copy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rect_copy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy one rectangle structure to another. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01071">1071</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01063">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01063">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l01065">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01064">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01062">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01061">rect::x</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01061">rect::y</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01644">rect_improve()</a>.
<p>
<div class="fragment"><pre>01072 {
01073   <span class="comment">/* check parameters */</span>
01074   <span class="keywordflow">if</span>( in == NULL || out == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"rect_copy: invalid 'in' or 'out'."</span>);
01075 
01076   <span class="comment">/* copy values */</span>
01077   out-&gt;<a class="code" href="structrect.html#o0">x1</a> = in-&gt;<a class="code" href="structrect.html#o0">x1</a>;
01078   out-&gt;<a class="code" href="structrect.html#o1">y1</a> = in-&gt;<a class="code" href="structrect.html#o1">y1</a>;
01079   out-&gt;<a class="code" href="structrect.html#o2">x2</a> = in-&gt;<a class="code" href="structrect.html#o2">x2</a>;
01080   out-&gt;<a class="code" href="structrect.html#o3">y2</a> = in-&gt;<a class="code" href="structrect.html#o3">y2</a>;
01081   out-&gt;<a class="code" href="structrect.html#o4">width</a> = in-&gt;<a class="code" href="structrect.html#o4">width</a>;
01082   out-&gt;<a class="code" href="structrect.html#o5">x</a> = in-&gt;<a class="code" href="structrect.html#o5">x</a>;
01083   out-&gt;<a class="code" href="structrect.html#o6">y</a> = in-&gt;<a class="code" href="structrect.html#o6">y</a>;
01084   out-&gt;<a class="code" href="structrect.html#o7">theta</a> = in-&gt;<a class="code" href="structrect.html#o7">theta</a>;
01085   out-&gt;<a class="code" href="structrect.html#o8">dx</a> = in-&gt;<a class="code" href="structrect.html#o8">dx</a>;
01086   out-&gt;<a class="code" href="structrect.html#o9">dy</a> = in-&gt;<a class="code" href="structrect.html#o9">dy</a>;
01087   out-&gt;<a class="code" href="structrect.html#o10">prec</a> = in-&gt;<a class="code" href="structrect.html#o10">prec</a>;
01088   out-&gt;<a class="code" href="structrect.html#o11">p</a> = in-&gt;<a class="code" href="structrect.html#o11">p</a>;
01089 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a37_cgraph.png" border="0" usemap="#lsd_8c_a37_cgraph_map" alt=""></center>
<map name="lsd_8c_a37_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="136,8,186,34" alt="">
</map>
<a class="anchor" name="a48" doxytag="lsd.c::rect_improve" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double rect_improve </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>eps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try some rectangles variations to improve NFA value. 
<p>
Only if the rectangle is not meaningful (i.e., log_nfa &lt;= eps). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01644">1644</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01063">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01063">rect::dy</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00085">M_PI</a>, <a class="el" href="lsd_8c-source.html#l01065">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01064">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01071">rect_copy()</a>, <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>01646 {
01647   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> r;
01648   <span class="keywordtype">double</span> log_nfa,log_nfa_new;
01649   <span class="keywordtype">double</span> delta = 0.5;
01650   <span class="keywordtype">double</span> delta_2 = delta / 2.0;
01651   <span class="keywordtype">int</span> n;
01652 
01653   log_nfa = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(rec,angles,logNT);
01654 
01655   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01656 
01657   <span class="comment">/* try finer precisions */</span>
01658   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01659   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01660     {
01661       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01662       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01663       log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01664       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01665         {
01666           log_nfa = log_nfa_new;
01667           <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01668         }
01669     }
01670 
01671   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01672 
01673   <span class="comment">/* try to reduce width */</span>
01674   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01675   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01676     {
01677       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01678         {
01679           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01680           log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01681           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01682             {
01683               <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01684               log_nfa = log_nfa_new;
01685             }
01686         }
01687     }
01688 
01689   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01690 
01691   <span class="comment">/* try to reduce one side of the rectangle */</span>
01692   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01693   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01694     {
01695       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01696         {
01697           r.<a class="code" href="structrect.html#o0">x1</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01698           r.<a class="code" href="structrect.html#o1">y1</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01699           r.<a class="code" href="structrect.html#o2">x2</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01700           r.<a class="code" href="structrect.html#o3">y2</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01701           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01702           log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01703           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01704             {
01705               <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01706               log_nfa = log_nfa_new;
01707             }
01708         }
01709     }
01710 
01711   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01712 
01713   <span class="comment">/* try to reduce the other side of the rectangle */</span>
01714   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01715   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01716     {
01717       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01718         {
01719           r.<a class="code" href="structrect.html#o0">x1</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01720           r.<a class="code" href="structrect.html#o1">y1</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01721           r.<a class="code" href="structrect.html#o2">x2</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01722           r.<a class="code" href="structrect.html#o3">y2</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01723           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01724           log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01725           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01726             {
01727               <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01728               log_nfa = log_nfa_new;
01729             }
01730         }
01731     }
01732 
01733   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01734 
01735   <span class="comment">/* try even finer precisions */</span>
01736   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01737   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01738     {
01739       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01740       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01741       log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01742       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01743         {
01744           log_nfa = log_nfa_new;
01745           <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01746         }
01747     }
01748 
01749   <span class="keywordflow">return</span> log_nfa;
01750 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a48_cgraph.png" border="0" usemap="#lsd_8c_a48_cgraph_map" alt=""></center>
<map name="lsd_8c_a48_cgraph_map">
<area href="lsd_8c.html#a37" shape="rect" coords="381,8,461,34" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="158,185,228,212" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="661,236,712,262" alt="">
<area href="lsd_8c.html#a31" shape="rect" coords="384,109,458,136" alt="">
<area href="lsd_8c.html#a36" shape="rect" coords="528,464,568,490" alt="">
<area href="lsd_8c.html#a40" shape="rect" coords="278,160,332,186" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="518,261,577,288" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="394,312,448,338" alt="">
<area href="lsd_8c.html#a43" shape="rect" coords="280,210,330,237" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="636,413,737,440" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="514,362,581,389" alt="">
<area href="lsd_8c.html#a38" shape="rect" coords="510,413,585,440" alt="">
</map>
<a class="anchor" name="a44" doxytag="lsd.c::rect_nfa" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double rect_nfa </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a rectangle's NFA value. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01370">1370</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l00962">nfa()</a>, <a class="el" href="lsd_8c-source.html#l01065">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01064">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01202">ri_del()</a>, <a class="el" href="lsd_8c-source.html#l01213">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01229">ri_inc()</a>, <a class="el" href="lsd_8c-source.html#l01299">ri_ini()</a>, <a class="el" href="lsd_8c-source.html#l01062">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01152">rect_iter::x</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01152">rect_iter::y</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01644">rect_improve()</a>.
<p>
<div class="fragment"><pre>01371 {
01372   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01373   <span class="keywordtype">int</span> pts = 0;
01374   <span class="keywordtype">int</span> alg = 0;
01375 
01376   <span class="comment">/* check parameters */</span>
01377   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"rect_nfa: invalid rectangle."</span>);
01378   <span class="keywordflow">if</span>( angles == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"rect_nfa: invalid 'angles'."</span>);
01379 
01380   <span class="comment">/* compute the total number of pixels and of aligned points in 'rec' */</span>
01381   <span class="keywordflow">for</span>(i=<a class="code" href="lsd_8c.html#a43">ri_ini</a>(rec); !<a class="code" href="lsd_8c.html#a41">ri_end</a>(i); <a class="code" href="lsd_8c.html#a42">ri_inc</a>(i)) <span class="comment">/* rectangle iterator */</span>
01382     <span class="keywordflow">if</span>( i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &gt;= 0 &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &gt;= 0 &amp;&amp;
01383         i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01384       {
01385         ++pts; <span class="comment">/* total number of pixels counter */</span>
01386         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a31">isaligned</a>(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>, i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>, angles, rec-&gt;<a class="code" href="structrect.html#o7">theta</a>, rec-&gt;<a class="code" href="structrect.html#o10">prec</a>) )
01387           ++alg; <span class="comment">/* aligned points counter */</span>
01388       }
01389   <a class="code" href="lsd_8c.html#a40">ri_del</a>(i); <span class="comment">/* delete iterator */</span>
01390 
01391   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a36">nfa</a>(pts,alg,rec-&gt;<a class="code" href="structrect.html#o11">p</a>,logNT); <span class="comment">/* compute NFA value */</span>
01392 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a44_cgraph.png" border="0" usemap="#lsd_8c_a44_cgraph_map" alt=""></center>
<map name="lsd_8c_a44_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="506,210,557,237" alt="">
<area href="lsd_8c.html#a31" shape="rect" coords="232,109,306,136" alt="">
<area href="lsd_8c.html#a36" shape="rect" coords="373,312,413,338" alt="">
<area href="lsd_8c.html#a40" shape="rect" coords="129,8,182,34" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="364,160,422,186" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="242,325,296,352" alt="">
<area href="lsd_8c.html#a43" shape="rect" coords="130,286,181,313" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="481,362,582,389" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="360,362,426,389" alt="">
<area href="lsd_8c.html#a38" shape="rect" coords="356,413,430,440" alt="">
</map>
<a class="anchor" name="a49" doxytag="lsd.c::reduce_region_radius" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int reduce_region_radius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reduce the region size, by elimination the points far from the starting point, until that leads to rectangle with the right density of region points or to discard the region if too small. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01757">1757</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00181">dist()</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l00089">FALSE</a>, <a class="el" href="lsd_8h.html#a1">image_char</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00106">NOTUSED</a>, <a class="el" href="lsd_8c-source.html#l01499">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l00093">TRUE</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l00123">point::x</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8h-source.html#l00083">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00123">point::y</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.
<p>
<div class="fragment"><pre>01762 {
01763   <span class="keywordtype">double</span> density,rad1,rad2,rad,xc,yc;
01764   <span class="keywordtype">int</span> i;
01765 
01766   <span class="comment">/* check parameters */</span>
01767   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg'."</span>);
01768   <span class="keywordflow">if</span>( reg_size == NULL )
01769     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg_size'."</span>);
01770   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: 'prec' must be positive."</span>);
01771   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'rec'."</span>);
01772   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01773     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'used'."</span>);
01774   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01775     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'angles'."</span>);
01776 
01777   <span class="comment">/* compute region points density */</span>
01778   density = (<span class="keywordtype">double</span>) *reg_size /
01779                          ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01780 
01781   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01782   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01783 
01784   <span class="comment">/* compute region's radius */</span>
01785   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01786   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01787   rad1 = <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o0">x1</a>, rec-&gt;<a class="code" href="structrect.html#o1">y1</a> );
01788   rad2 = <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o2">x2</a>, rec-&gt;<a class="code" href="structrect.html#o3">y2</a> );
01789   rad = rad1 &gt; rad2 ? rad1 : rad2;
01790 
01791   <span class="comment">/* while the density criterion is not satisfied, remove farther pixels */</span>
01792   <span class="keywordflow">while</span>( density &lt; density_th )
01793     {
01794       rad *= 0.75; <span class="comment">/* reduce region's radius to 75% of its value */</span>
01795 
01796       <span class="comment">/* remove points from the region and update 'used' map */</span>
01797       <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01798         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &gt; rad )
01799           {
01800             <span class="comment">/* point not kept, mark it as NOTUSED */</span>
01801             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01802             <span class="comment">/* remove point from the region */</span>
01803             reg[i].<a class="code" href="structpoint.html#o0">x</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o0">x</a>; <span class="comment">/* if i==*reg_size-1 copy itself */</span>
01804             reg[i].<a class="code" href="structpoint.html#o1">y</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o1">y</a>;
01805             --(*reg_size);
01806             --i; <span class="comment">/* to avoid skipping one point */</span>
01807           }
01808 
01809       <span class="comment">/* reject if the region is too small.</span>
01810 <span class="comment">         2 is the minimal region size for 'region2rect' to work. */</span>
01811       <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01812 
01813       <span class="comment">/* re-compute rectangle */</span>
01814       <a class="code" href="lsd_8c.html#a46">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01815 
01816       <span class="comment">/* re-compute region points density */</span>
01817       density = (<span class="keywordtype">double</span>) *reg_size /
01818                          ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01819     }
01820 
01821   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01822   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01823 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a49_cgraph.png" border="0" usemap="#lsd_8c_a49_cgraph_map" alt=""></center>
<map name="lsd_8c_a49_cgraph_map">
<area href="lsd_8c.html#a14" shape="rect" coords="232,7,274,34" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="498,109,549,135" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="209,109,297,135" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="346,159,424,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="484,159,564,186" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="473,210,574,237" alt="">
</map>
<a class="anchor" name="a50" doxytag="lsd.c::refine" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int refine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refine a rectangle. 
<p>
For that, an estimation of the angle tolerance is performed by the standard deviation of the angle at points near the region's starting point. Then, a new region is grown starting from the same point, but using the estimated angle tolerance. If this fails to produce a rectangle with the right density of region points, 'reduce_region_radius' is called to try to satisfy this condition. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01835">1835</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00831">angle_diff_signed()</a>, <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00181">dist()</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l00089">FALSE</a>, <a class="el" href="lsd_8h.html#a1">image_char</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00106">NOTUSED</a>, <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01499">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01592">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l00093">TRUE</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l00123">point::x</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8h-source.html#l00083">image_char_s::xsize</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00123">point::y</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>01838 {
01839   <span class="keywordtype">double</span> angle,ang_d,mean_angle,tau,density,xc,yc,ang_c,sum,s_sum;
01840   <span class="keywordtype">int</span> i,n;
01841 
01842   <span class="comment">/* check parameters */</span>
01843   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg'."</span>);
01844   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg_size'."</span>);
01845   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: 'prec' must be positive."</span>);
01846   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid pointer 'rec'."</span>);
01847   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01848     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid image 'used'."</span>);
01849   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01850     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid image 'angles'."</span>);
01851 
01852   <span class="comment">/* compute region points density */</span>
01853   density = (<span class="keywordtype">double</span>) *reg_size /
01854                          ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01855 
01856   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01857   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01858 
01859   <span class="comment">/*------ First try: reduce angle tolerance ------*/</span>
01860 
01861   <span class="comment">/* compute the new mean angle and tolerance */</span>
01862   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01863   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01864   ang_c = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[0].<a class="code" href="structpoint.html#o0">x</a> + reg[0].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01865   sum = s_sum = 0.0;
01866   n = 0;
01867   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01868     {
01869       used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01870       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &lt; rec-&gt;<a class="code" href="structrect.html#o4">width</a> )
01871         {
01872           angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01873           ang_d = <a class="code" href="lsd_8c.html#a33">angle_diff_signed</a>(angle,ang_c);
01874           sum += ang_d;
01875           s_sum += ang_d * ang_d;
01876           ++n;
01877         }
01878     }
01879   mean_angle = sum / (<span class="keywordtype">double</span>) n;
01880   tau = 2.0 * sqrt( (s_sum - 2.0 * mean_angle * sum) / (<span class="keywordtype">double</span>) n
01881                          + mean_angle*mean_angle ); <span class="comment">/* 2 * standard deviation */</span>
01882 
01883   <span class="comment">/* find a new region from the same starting point and new angle tolerance */</span>
01884   <a class="code" href="lsd_8c.html#a47">region_grow</a>(reg[0].x,reg[0].y,angles,reg,reg_size,&amp;reg_angle,used,tau);
01885 
01886   <span class="comment">/* if the region is too small, reject */</span>
01887   <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01888 
01889   <span class="comment">/* re-compute rectangle */</span>
01890   <a class="code" href="lsd_8c.html#a46">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01891 
01892   <span class="comment">/* re-compute region points density */</span>
01893   density = (<span class="keywordtype">double</span>) *reg_size /
01894                       ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01895 
01896   <span class="comment">/*------ Second try: reduce region radius ------*/</span>
01897   <span class="keywordflow">if</span>( density &lt; density_th )
01898     <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a49">reduce_region_radius</a>( reg, reg_size, modgrad, reg_angle, prec, p,
01899                                  rec, used, angles, density_th );
01900 
01901   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01902   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01903 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a50_cgraph.png" border="0" usemap="#lsd_8c_a50_cgraph_map" alt=""></center>
<map name="lsd_8c_a50_cgraph_map">
<area href="lsd_8c.html#a33" shape="rect" coords="125,8,250,34" alt="">
<area href="lsd_8c.html#a14" shape="rect" coords="338,160,381,186" alt="">
<area href="lsd_8c.html#a12" shape="rect" coords="607,210,658,237" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="113,210,262,237" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="315,261,403,288" alt="">
<area href="lsd_8c.html#a47" shape="rect" coords="313,109,406,136" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="455,312,533,338" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="593,337,673,364" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="582,286,683,313" alt="">
<area href="lsd_8c.html#a31" shape="rect" coords="457,160,531,186" alt="">
</map>
<a class="anchor" name="a46" doxytag="lsd.c::region2rect" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void region2rect </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes a rectangle that covers a region of points. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01499">1499</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l01063">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01063">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l01456">get_theta()</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l01065">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01064">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01062">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01061">rect::x</a>, <a class="el" href="lsd_8c-source.html#l00123">point::x</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01061">rect::y</a>, <a class="el" href="lsd_8c-source.html#l00123">point::y</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l01757">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.
<p>
<div class="fragment"><pre>01502 {
01503   <span class="keywordtype">double</span> x,y,dx,dy,l,w,theta,weight,sum,l_min,l_max,w_min,w_max;
01504   <span class="keywordtype">int</span> i;
01505 
01506   <span class="comment">/* check parameters */</span>
01507   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: invalid region."</span>);
01508   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: region size &lt;= 1."</span>);
01509   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01510     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: invalid image 'modgrad'."</span>);
01511   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: invalid 'rec'."</span>);
01512 
01513   <span class="comment">/* center of the region:</span>
01514 <span class="comment"></span>
01515 <span class="comment">     It is computed as the weighted sum of the coordinates</span>
01516 <span class="comment">     of all the pixels in the region. The norm of the gradient</span>
01517 <span class="comment">     is used as the weight of a pixel. The sum is as follows:</span>
01518 <span class="comment">       cx = \sum_i G(i).x_i</span>
01519 <span class="comment">       cy = \sum_i G(i).y_i</span>
01520 <span class="comment">     where G(i) is the norm of the gradient of pixel i</span>
01521 <span class="comment">     and x_i,y_i are its coordinates.</span>
01522 <span class="comment">   */</span>
01523   x = y = sum = 0.0;
01524   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01525     {
01526       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01527       x += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> * weight;
01528       y += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> * weight;
01529       sum += weight;
01530     }
01531   <span class="keywordflow">if</span>( sum &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: weights sum equal to zero."</span>);
01532   x /= sum;
01533   y /= sum;
01534 
01535   <span class="comment">/* theta */</span>
01536   theta = <a class="code" href="lsd_8c.html#a45">get_theta</a>(reg,reg_size,x,y,modgrad,reg_angle,prec);
01537 
01538   <span class="comment">/* length and width:</span>
01539 <span class="comment"></span>
01540 <span class="comment">     'l' and 'w' are computed as the distance from the center of the</span>
01541 <span class="comment">     region to pixel i, projected along the rectangle axis (dx,dy) and</span>
01542 <span class="comment">     to the orthogonal axis (-dy,dx), respectively.</span>
01543 <span class="comment"></span>
01544 <span class="comment">     The length of the rectangle goes from l_min to l_max, where l_min</span>
01545 <span class="comment">     and l_max are the minimum and maximum values of l in the region.</span>
01546 <span class="comment">     Analogously, the width is selected from w_min to w_max, where</span>
01547 <span class="comment">     w_min and w_max are the minimum and maximum of w for the pixels</span>
01548 <span class="comment">     in the region.</span>
01549 <span class="comment">   */</span>
01550   dx = cos(theta);
01551   dy = sin(theta);
01552   l_min = l_max = w_min = w_max = 0.0;
01553   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01554     {
01555       l =  ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dx + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dy;
01556       w = -( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dy + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dx;
01557 
01558       <span class="keywordflow">if</span>( l &gt; l_max ) l_max = l;
01559       <span class="keywordflow">if</span>( l &lt; l_min ) l_min = l;
01560       <span class="keywordflow">if</span>( w &gt; w_max ) w_max = w;
01561       <span class="keywordflow">if</span>( w &lt; w_min ) w_min = w;
01562     }
01563 
01564   <span class="comment">/* store values */</span>
01565   rec-&gt;<a class="code" href="structrect.html#o0">x1</a> = x + l_min * dx;
01566   rec-&gt;<a class="code" href="structrect.html#o1">y1</a> = y + l_min * dy;
01567   rec-&gt;<a class="code" href="structrect.html#o2">x2</a> = x + l_max * dx;
01568   rec-&gt;<a class="code" href="structrect.html#o3">y2</a> = y + l_max * dy;
01569   rec-&gt;<a class="code" href="structrect.html#o4">width</a> = w_max - w_min;
01570   rec-&gt;<a class="code" href="structrect.html#o5">x</a> = x;
01571   rec-&gt;<a class="code" href="structrect.html#o6">y</a> = y;
01572   rec-&gt;<a class="code" href="structrect.html#o7">theta</a> = theta;
01573   rec-&gt;<a class="code" href="structrect.html#o8">dx</a> = dx;
01574   rec-&gt;<a class="code" href="structrect.html#o9">dy</a> = dy;
01575   rec-&gt;<a class="code" href="structrect.html#o10">prec</a> = prec;
01576   rec-&gt;<a class="code" href="structrect.html#o11">p</a> = p;
01577 
01578   <span class="comment">/* we impose a minimal width of one pixel</span>
01579 <span class="comment"></span>
01580 <span class="comment">     A sharp horizontal or vertical step would produce a perfectly</span>
01581 <span class="comment">     horizontal or vertical region. The width computed would be</span>
01582 <span class="comment">     zero. But that corresponds to a one pixels width transition in</span>
01583 <span class="comment">     the image.</span>
01584 <span class="comment">   */</span>
01585   <span class="keywordflow">if</span>( rec-&gt;<a class="code" href="structrect.html#o4">width</a> &lt; 1.0 ) rec-&gt;<a class="code" href="structrect.html#o4">width</a> = 1.0;
01586 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a46_cgraph.png" border="0" usemap="#lsd_8c_a46_cgraph_map" alt=""></center>
<map name="lsd_8c_a46_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="298,8,349,34" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="146,58,224,85" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="284,58,364,85" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="273,109,374,136" alt="">
</map>
<a class="anchor" name="a47" doxytag="lsd.c::region_grow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void region_grow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a region of pixels that share the same angle, up to a tolerance 'prec', starting at point (x,y). 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01592">1592</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8h-source.html#l00082">image_char_s::data</a>, <a class="el" href="lsd_8h-source.html#l00122">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8h.html#a1">image_char</a>, <a class="el" href="lsd_8h.html#a3">image_double</a>, <a class="el" href="lsd_8c-source.html#l00781">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l00109">USED</a>, <a class="el" href="lsd_8c-source.html#l00123">point::x</a>, <a class="el" href="lsd_8h-source.html#l00083">image_char_s::xsize</a>, <a class="el" href="lsd_8h-source.html#l00123">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00123">point::y</a>, <a class="el" href="lsd_8h-source.html#l00083">image_char_s::ysize</a>, and <a class="el" href="lsd_8h-source.html#l00123">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01913">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l01835">refine()</a>.
<p>
<div class="fragment"><pre>01595 {
01596   <span class="keywordtype">double</span> sumdx,sumdy;
01597   <span class="keywordtype">int</span> xx,yy,i;
01598 
01599   <span class="comment">/* check parameters */</span>
01600   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01601     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: (x,y) out of the image."</span>);
01602   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01603     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid image 'angles'."</span>);
01604   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid 'reg'."</span>);
01605   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_size'."</span>);
01606   <span class="keywordflow">if</span>( reg_angle == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_angle'."</span>);
01607   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01608     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid image 'used'."</span>);
01609 
01610   <span class="comment">/* first point of the region */</span>
01611   *reg_size = 1;
01612   reg[0].<a class="code" href="structpoint.html#o0">x</a> = x;
01613   reg[0].<a class="code" href="structpoint.html#o1">y</a> = y;
01614   *reg_angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[x+y*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>];  <span class="comment">/* region's angle */</span>
01615   sumdx = cos(*reg_angle);
01616   sumdy = sin(*reg_angle);
01617   used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[x+y*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01618 
01619   <span class="comment">/* try neighbors as new region points */</span>
01620   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01621     <span class="keywordflow">for</span>(xx=reg[i].<a class="code" href="structpoint.html#o0">x</a>-1; xx&lt;=reg[i].x+1; xx++)
01622       <span class="keywordflow">for</span>(yy=reg[i].y-1; yy&lt;=reg[i].y+1; yy++)
01623         <span class="keywordflow">if</span>( xx&gt;=0 &amp;&amp; yy&gt;=0 &amp;&amp; xx&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> &amp;&amp; yy&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> &amp;&amp;
01624             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] != <a class="code" href="lsd_8c.html#a8">USED</a> &amp;&amp;
01625             <a class="code" href="lsd_8c.html#a31">isaligned</a>(xx,yy,angles,*reg_angle,prec) )
01626           {
01627             <span class="comment">/* add point */</span>
01628             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01629             reg[*reg_size].x = xx;
01630             reg[*reg_size].y = yy;
01631             ++(*reg_size);
01632 
01633             <span class="comment">/* update region's angle */</span>
01634             sumdx += cos( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01635             sumdy += sin( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01636             *reg_angle = atan2(sumdy,sumdx);
01637           }
01638 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a47_cgraph.png" border="0" usemap="#lsd_8c_a47_cgraph_map" alt=""></center>
<map name="lsd_8c_a47_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="274,33,325,59" alt="">
<area href="lsd_8c.html#a31" shape="rect" coords="151,58,226,85" alt="">
</map>
<a class="anchor" name="a40" doxytag="lsd.c::ri_del" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ri_del </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used by a rectangle iterator. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01202">1202</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00133">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01203 {
01204   <span class="keywordflow">if</span>( iter == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_del: NULL iterator."</span>);
01205   free( (<span class="keywordtype">void</span> *) iter );
01206 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a40_cgraph.png" border="0" usemap="#lsd_8c_a40_cgraph_map" alt=""></center>
<map name="lsd_8c_a40_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="112,8,162,34" alt="">
</map>
<a class="anchor" name="a41" doxytag="lsd.c::ri_end" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ri_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the iterator finished the full iteration. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01213">1213</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l01149">rect_iter::vx</a>, and <a class="el" href="lsd_8c-source.html#l01152">rect_iter::x</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01229">ri_inc()</a>.
<p>
<div class="fragment"><pre>01214 {
01215   <span class="comment">/* check input */</span>
01216   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_end: NULL iterator."</span>);
01217 
01218   <span class="comment">/* if the current x value is larger than the larger</span>
01219 <span class="comment">     x value in the rectangle (vx[2]), we know the full</span>
01220 <span class="comment">     exploration of the rectangle is finished. */</span>
01221   <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2];
01222 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a41_cgraph.png" border="0" usemap="#lsd_8c_a41_cgraph_map" alt=""></center>
<map name="lsd_8c_a41_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="114,8,165,34" alt="">
</map>
<a class="anchor" name="a42" doxytag="lsd.c::ri_inc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ri_inc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment a rectangle iterator. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01229">1229</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l01187">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01165">inter_low()</a>, <a class="el" href="lsd_8c-source.html#l01213">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01149">rect_iter::vx</a>, <a class="el" href="lsd_8c-source.html#l01150">rect_iter::vy</a>, <a class="el" href="lsd_8c-source.html#l01152">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l01152">rect_iter::y</a>, <a class="el" href="lsd_8c-source.html#l01151">rect_iter::ye</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect_iter::ys</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01299">ri_ini()</a>.
<p>
<div class="fragment"><pre>01230 {
01231   <span class="comment">/* check input */</span>
01232   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_inc: NULL iterator."</span>);
01233 
01234   <span class="comment">/* if not at end of exploration,</span>
01235 <span class="comment">     increase y value for next pixel in the 'column' */</span>
01236   <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a41">ri_end</a>(i) ) i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>++;
01237 
01238   <span class="comment">/* if the end of the current 'column' is reached,</span>
01239 <span class="comment">     and it is not the end of exploration,</span>
01240 <span class="comment">     advance to the next 'column' */</span>
01241   <span class="keywordflow">while</span>( (<span class="keywordtype">double</span>) (i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> &amp;&amp; !<a class="code" href="lsd_8c.html#a41">ri_end</a>(i) )
01242     {
01243       <span class="comment">/* increase x, next 'column' */</span>
01244       i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>++;
01245 
01246       <span class="comment">/* if end of exploration, return */</span>
01247       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a41">ri_end</a>(i) ) <span class="keywordflow">return</span>;
01248 
01249       <span class="comment">/* update lower y limit (start) for the new 'column'.</span>
01250 <span class="comment"></span>
01251 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01252 <span class="comment">         lower side of the rectangle. The first thing is to decide if</span>
01253 <span class="comment">         the corresponding side is</span>
01254 <span class="comment"></span>
01255 <span class="comment">           vx[0],vy[0] to vx[3],vy[3] or</span>
01256 <span class="comment">           vx[3],vy[3] to vx[2],vy[2]</span>
01257 <span class="comment"></span>
01258 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01259 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01260 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01261 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01262 <span class="comment">         by using 'inter_low'.</span>
01263 <span class="comment">       */</span>
01264       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3] )
01265         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a38">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3]);
01266       <span class="keywordflow">else</span>
01267         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a38">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01268 
01269       <span class="comment">/* update upper y limit (end) for the new 'column'.</span>
01270 <span class="comment"></span>
01271 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01272 <span class="comment">         upper side of the rectangle. The first thing is to decide if</span>
01273 <span class="comment">         the corresponding side is</span>
01274 <span class="comment"></span>
01275 <span class="comment">           vx[0],vy[0] to vx[1],vy[1] or</span>
01276 <span class="comment">           vx[1],vy[1] to vx[2],vy[2]</span>
01277 <span class="comment"></span>
01278 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01279 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01280 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01281 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01282 <span class="comment">         by using 'inter_low'.</span>
01283 <span class="comment">       */</span>
01284       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1] )
01285         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a39">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1]);
01286       <span class="keywordflow">else</span>
01287         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a39">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01288 
01289       <span class="comment">/* new y */</span>
01290       i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a>);
01291     }
01292 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a42_cgraph.png" border="0" usemap="#lsd_8c_a42_cgraph_map" alt=""></center>
<map name="lsd_8c_a42_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="263,72,314,98" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="117,109,183,136" alt="">
<area href="lsd_8c.html#a38" shape="rect" coords="113,160,187,186" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="121,58,179,85" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="238,148,339,174" alt="">
</map>
<a class="anchor" name="a43" doxytag="lsd.c::ri_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structrect__iter.html">rect_iter</a>* ri_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create and initialize a rectangle iterator. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01299">1299</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01063">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01063">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00133">error()</a>, <a class="el" href="lsd_8c-source.html#l01229">ri_inc()</a>, <a class="el" href="lsd_8c-source.html#l01149">rect_iter::vx</a>, <a class="el" href="lsd_8c-source.html#l01150">rect_iter::vy</a>, <a class="el" href="lsd_8c-source.html#l01060">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01152">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01152">rect_iter::y</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01059">rect::y2</a>, <a class="el" href="lsd_8c-source.html#l01151">rect_iter::ye</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect_iter::ys</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01370">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01300 {
01301   <span class="keywordtype">double</span> vx[4],vy[4];
01302   <span class="keywordtype">int</span> n,offset;
01303   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01304 
01305   <span class="comment">/* check parameters */</span>
01306   <span class="keywordflow">if</span>( r == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_ini: invalid rectangle."</span>);
01307 
01308   <span class="comment">/* get memory */</span>
01309   i = (<a class="code" href="structrect__iter.html">rect_iter</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structrect__iter.html">rect_iter</a>));
01310   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_ini: Not enough memory."</span>);
01311 
01312   <span class="comment">/* build list of rectangle corners ordered</span>
01313 <span class="comment">     in a circular way around the rectangle */</span>
01314   vx[0] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01315   vy[0] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01316   vx[1] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01317   vy[1] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01318   vx[2] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01319   vy[2] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01320   vx[3] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01321   vy[3] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01322 
01323   <span class="comment">/* compute rotation of index of corners needed so that the first</span>
01324 <span class="comment">     point has the smaller x.</span>
01325 <span class="comment"></span>
01326 <span class="comment">     if one side is vertical, thus two corners have the same smaller x</span>
01327 <span class="comment">     value, the one with the largest y value is selected as the first.</span>
01328 <span class="comment">   */</span>
01329   <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &lt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 0;
01330   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt; r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 1;
01331   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 2;
01332   <span class="keywordflow">else</span> offset = 3;
01333 
01334   <span class="comment">/* apply rotation of index. */</span>
01335   <span class="keywordflow">for</span>(n=0; n&lt;4; n++)
01336     {
01337       i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[n] = vx[(offset+n)%4];
01338       i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[n] = vy[(offset+n)%4];
01339     }
01340 
01341   <span class="comment">/* Set a initial condition.</span>
01342 <span class="comment"></span>
01343 <span class="comment">     The values are set to values that will cause 'ri_inc' (that will</span>
01344 <span class="comment">     be called immediately) to initialize correctly the first 'column'</span>
01345 <span class="comment">     and compute the limits 'ys' and 'ye'.</span>
01346 <span class="comment"></span>
01347 <span class="comment">     'y' is set to the integer value of vy[0], the starting corner.</span>
01348 <span class="comment"></span>
01349 <span class="comment">     'ys' and 'ye' are set to very small values, so 'ri_inc' will</span>
01350 <span class="comment">     notice that it needs to start a new 'column'.</span>
01351 <span class="comment"></span>
01352 <span class="comment">     The smaller integer coordinate inside of the rectangle is</span>
01353 <span class="comment">     'ceil(vx[0])'. The current 'x' value is set to that value minus</span>
01354 <span class="comment">     one, so 'ri_inc' (that will increase x by one) will advance to</span>
01355 <span class="comment">     the first 'column'.</span>
01356 <span class="comment">   */</span>
01357   i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0]) - 1;
01358   i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0]);
01359   i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = -DBL_MAX;
01360 
01361   <span class="comment">/* advance to the first pixel */</span>
01362   <a class="code" href="lsd_8c.html#a42">ri_inc</a>(i);
01363 
01364   <span class="keywordflow">return</span> i;
01365 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a43_cgraph.png" border="0" usemap="#lsd_8c_a43_cgraph_map" alt=""></center>
<map name="lsd_8c_a43_cgraph_map">
<area href="lsd_8c.html#a12" shape="rect" coords="362,109,413,135" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="108,109,161,135" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="216,159,282,186" alt="">
<area href="lsd_8c.html#a38" shape="rect" coords="212,210,286,237" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="220,109,278,135" alt="">
<area href="lsd_8c.html#a13" shape="rect" coords="337,185,438,211" alt="">
</map>
<hr size="1"><address style="align: right;"><small>Generated on Fri Dec 3 10:18:38 2010 for LSD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
