<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSD: lsd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lsd.c</h1><a href="lsd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*----------------------------------------------------------------------------</span>
00002 <span class="comment"></span>
00003 <span class="comment">  LSD - Line Segment Detector on digital images</span>
00004 <span class="comment"></span>
00005 <span class="comment">  Copyright 2007-2010 rafael grompone von gioi (grompone@gmail.com)</span>
00006 <span class="comment"></span>
00007 <span class="comment">  This program is free software: you can redistribute it and/or modify</span>
00008 <span class="comment">  it under the terms of the GNU Affero General Public License as</span>
00009 <span class="comment">  published by the Free Software Foundation, either version 3 of the</span>
00010 <span class="comment">  License, or (at your option) any later version.</span>
00011 <span class="comment"></span>
00012 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00013 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
00015 <span class="comment">  GNU Affero General Public License for more details.</span>
00016 <span class="comment"></span>
00017 <span class="comment">  You should have received a copy of the GNU Affero General Public License</span>
00018 <span class="comment">  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
00019 <span class="comment"></span>
00020 <span class="comment">  ----------------------------------------------------------------------------*/</span>
00021 
00022 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00023 <span class="comment">/** @file lsd.c</span>
00024 <span class="comment">    LSD module code</span>
00025 <span class="comment">    @author rafael grompone von gioi (grompone@gmail.com)</span>
00026 <span class="comment"> */</span>
00027 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00028 
00029 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00030 <span class="comment">/** @mainpage LSD code documentation</span>
00031 <span class="comment"></span>
00032 <span class="comment">    This is an implementation of the Line Segment Detector described</span>
00033 <span class="comment">    in the paper:</span>
00034 <span class="comment"></span>
00035 <span class="comment">      "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
00036 <span class="comment">      by Rafael Grompone von Gioi, Jeremie Jakubowicz, Jean-Michel Morel,</span>
00037 <span class="comment">      and Gregory Randall, IEEE Transactions on Pattern Analysis and</span>
00038 <span class="comment">      Machine Intelligence, vol. 32, no. 4, pp. 722-732, April, 2010.</span>
00039 <span class="comment"></span>
00040 <span class="comment">    and in more details in the CMLA Technical Report:</span>
00041 <span class="comment"></span>
00042 <span class="comment">      "LSD: A Line Segment Detector, Technical Report",</span>
00043 <span class="comment">      by Rafael Grompone von Gioi, Jeremie Jakubowicz, Jean-Michel Morel,</span>
00044 <span class="comment">      Gregory Randall, CMLA, ENS Cachan, 2010.</span>
00045 <span class="comment"></span>
00046 <span class="comment">    The version implemented here includes some further improvements</span>
00047 <span class="comment">    described on the LSD page at www.ipol.im. That same page includes</span>
00048 <span class="comment">    more information, including this code and an online demo version:</span>
00049 <span class="comment"></span>
00050 <span class="comment">      http://www.ipol.im/pub/algo/gjmr_line_segment_detector</span>
00051 <span class="comment"></span>
00052 <span class="comment">    The module's main function is lsd().</span>
00053 <span class="comment"></span>
00054 <span class="comment">    The source code is contained in two files: lsd.h and lsd.c.</span>
00055 <span class="comment"></span>
00056 <span class="comment">    HISTORY:</span>
00057 <span class="comment">    - version 1.5 - dic 2010: Changes in 'refine', -W option added,</span>
00058 <span class="comment">                              and more comments added.</span>
00059 <span class="comment">    - version 1.4 - jul 2010: lsd_scale interface added and doxygen doc.</span>
00060 <span class="comment">    - version 1.3 - feb 2010: Multiple bug correction and improved code.</span>
00061 <span class="comment">    - version 1.2 - dic 2009: First full Ansi C Language version.</span>
00062 <span class="comment">    - version 1.1 - sep 2009: Systematic subsampling to scale 0.8 and</span>
00063 <span class="comment">                              correction to partially handle"angle problem".</span>
00064 <span class="comment">    - version 1.0 - jan 2009: First complete Megawave2 and Ansi C Language</span>
00065 <span class="comment">                              version.</span>
00066 <span class="comment"></span>
00067 <span class="comment">    @author rafael grompone von gioi (grompone@gmail.com)</span>
00068 <span class="comment"> */</span>
00069 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00070 
00071 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00072 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00073 <span class="preprocessor">#include &lt;math.h&gt;</span>
00074 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00075 <span class="preprocessor">#include &lt;float.h&gt;</span>
00076 <span class="preprocessor">#include "<a class="code" href="lsd_8h.html">lsd.h</a>"</span>
00077 <span class="comment"></span>
00078 <span class="comment">/** ln(10) */</span>
00079 <span class="preprocessor">#ifndef M_LN10</span>
<a name="l00080"></a><a class="code" href="lsd_8c.html#a0">00080</a> <span class="preprocessor"></span><span class="preprocessor">#define M_LN10 2.30258509299404568402</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !M_LN10 */</span>
00082 <span class="comment"></span>
00083 <span class="comment">/** PI */</span>
00084 <span class="preprocessor">#ifndef M_PI</span>
<a name="l00085"></a><a class="code" href="lsd_8c.html#a1">00085</a> <span class="preprocessor"></span><span class="preprocessor">#define M_PI   3.14159265358979323846</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !M_PI */</span>
00087 
00088 <span class="preprocessor">#ifndef FALSE</span>
<a name="l00089"></a><a class="code" href="lsd_8c.html#a2">00089</a> <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !FALSE */</span>
00091 
00092 <span class="preprocessor">#ifndef TRUE</span>
<a name="l00093"></a><a class="code" href="lsd_8c.html#a3">00093</a> <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !TRUE */</span>
00095 <span class="comment"></span>
00096 <span class="comment">/** Label for pixels with undefined gradient. */</span>
<a name="l00097"></a><a class="code" href="lsd_8c.html#a4">00097</a> <span class="preprocessor">#define NOTDEF -1024.0</span>
00098 <span class="preprocessor"></span><span class="comment"></span>
00099 <span class="comment">/** 3/2 pi */</span>
<a name="l00100"></a><a class="code" href="lsd_8c.html#a5">00100</a> <span class="preprocessor">#define M_3_2_PI 4.71238898038</span>
00101 <span class="preprocessor"></span><span class="comment"></span>
00102 <span class="comment">/** 2 pi */</span>
<a name="l00103"></a><a class="code" href="lsd_8c.html#a6">00103</a> <span class="preprocessor">#define M_2__PI  6.28318530718</span>
00104 <span class="preprocessor"></span><span class="comment"></span>
00105 <span class="comment">/** Label for pixels not used in yet. */</span>
<a name="l00106"></a><a class="code" href="lsd_8c.html#a7">00106</a> <span class="preprocessor">#define NOTUSED 0</span>
00107 <span class="preprocessor"></span><span class="comment"></span>
00108 <span class="comment">/** Label for pixels already used in detection. */</span>
<a name="l00109"></a><a class="code" href="lsd_8c.html#a8">00109</a> <span class="preprocessor">#define USED    1</span>
00110 <span class="preprocessor"></span>
00111 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00112 <span class="comment">/** Chained list of coordinates.</span>
00113 <span class="comment"> */</span>
<a name="l00114"></a><a class="code" href="structcoorlist.html">00114</a> <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a>
00115 {
<a name="l00116"></a><a class="code" href="structcoorlist.html#o1">00116</a>   <span class="keywordtype">int</span> <a class="code" href="structcoorlist.html#o0">x</a>,<a class="code" href="structcoorlist.html#o1">y</a>;
<a name="l00117"></a><a class="code" href="structcoorlist.html#o2">00117</a>   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * <a class="code" href="structcoorlist.html#o2">next</a>;
00118 };
00119 
00120 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00121 <span class="comment">/** A point (or pixel).</span>
00122 <span class="comment"> */</span>
<a name="l00123"></a><a class="code" href="structpoint.html#o1">00123</a> <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> {<span class="keywordtype">int</span> <a class="code" href="structpoint.html#o0">x</a>,<a class="code" href="structpoint.html#o1">y</a>;};
00124 
00125 
00126 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00127 <span class="comment">/*------------------------- Miscellaneous functions --------------------------*/</span>
00128 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00129 
00130 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00131 <span class="comment">/** Fatal error, print a message to standard-error output and exit.</span>
00132 <span class="comment"> */</span>
<a name="l00133"></a><a class="code" href="lsd_8c.html#a12">00133</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a12">error</a>(<span class="keywordtype">char</span> * msg)
00134 {
00135   fprintf(stderr,<span class="stringliteral">"LSD Error: %s\n"</span>,msg);
00136   exit(EXIT_FAILURE);
00137 }
00138 
00139 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00140 <span class="comment">/** Doubles relative error factor</span>
00141 <span class="comment"> */</span>
<a name="l00142"></a><a class="code" href="lsd_8c.html#a9">00142</a> <span class="preprocessor">#define RELATIVE_ERROR_FACTOR 100.0</span>
00143 <span class="preprocessor"></span>
00144 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00145 <span class="comment">/** Compare doubles by relative error.</span>
00146 <span class="comment"></span>
00147 <span class="comment">    The resulting rounding error after floating point computations</span>
00148 <span class="comment">    depend on the specific operations done. The same number computed by</span>
00149 <span class="comment">    different algorithms could present different rounding errors. For a</span>
00150 <span class="comment">    useful comparison, an estimation of the relative rounding error</span>
00151 <span class="comment">    should be considered and compared to a factor times EPS. The factor</span>
00152 <span class="comment">    should be related to the cumulated rounding error in the chain of</span>
00153 <span class="comment">    computation. Here, as a simplification, a fixed factor is used.</span>
00154 <span class="comment"> */</span>
<a name="l00155"></a><a class="code" href="lsd_8c.html#a13">00155</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a13">double_equal</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
00156 {
00157   <span class="keywordtype">double</span> abs_diff,aa,bb,abs_max;
00158 
00159   <span class="comment">/* trivial case */</span>
00160   <span class="keywordflow">if</span>( a == b ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
00161 
00162   abs_diff = fabs(a-b);
00163   aa = fabs(a);
00164   bb = fabs(b);
00165   abs_max = aa &gt; bb ? aa : bb;
00166 
00167   <span class="comment">/* DBL_MIN is the smallest normalized number, thus, the smallest</span>
00168 <span class="comment">     number whose relative error is bounded by DBL_EPSILON. For</span>
00169 <span class="comment">     smaller numbers, the same quantization steps as for DBL_MIN</span>
00170 <span class="comment">     are used. Then, for smaller numbers, a meaningful "relative"</span>
00171 <span class="comment">     error should be computed by dividing the difference by DBL_MIN. */</span>
00172   <span class="keywordflow">if</span>( abs_max &lt; DBL_MIN ) abs_max = DBL_MIN;
00173 
00174   <span class="comment">/* equal if relative error &lt;= factor x eps */</span>
00175   <span class="keywordflow">return</span> (abs_diff / abs_max) &lt;= (<a class="code" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a> * DBL_EPSILON);
00176 }
00177 
00178 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00179 <span class="comment">/** Computes Euclidean distance between point (x1,y1) and point (x2,y2).</span>
00180 <span class="comment"> */</span>
<a name="l00181"></a><a class="code" href="lsd_8c.html#a14">00181</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a14">dist</a>(<span class="keywordtype">double</span> x1, <span class="keywordtype">double</span> y1, <span class="keywordtype">double</span> x2, <span class="keywordtype">double</span> y2)
00182 {
00183   <span class="keywordflow">return</span> sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
00184 }
00185 
00186 
00187 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00188 <span class="comment">/*----------------------- 'list of n-tuple' data type ------------------------*/</span>
00189 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00190 
00191 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00192 <span class="comment">/** Free memory used in n-tuple 'in'.</span>
00193 <span class="comment"> */</span>
<a name="l00194"></a><a class="code" href="lsd_8c.html#a15">00194</a> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a15">free_ntuple_list</a>(<a class="code" href="structntuple__list__s.html">ntuple_list</a> in)
00195 {
00196   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00197     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_ntuple_list: invalid n-tuple input."</span>);
00198   free( (<span class="keywordtype">void</span> *) in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> );
00199   free( (<span class="keywordtype">void</span> *) in );
00200 }
00201 
00202 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00203 <span class="comment">/** Create an n-tuple list and allocate memory for one element.</span>
00204 <span class="comment">    @param dim the dimension (n) of the n-tuple.</span>
00205 <span class="comment"> */</span>
<a name="l00206"></a><a class="code" href="lsd_8c.html#a16">00206</a> <a class="code" href="structntuple__list__s.html">ntuple_list</a> <a class="code" href="lsd_8c.html#a16">new_ntuple_list</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim)
00207 {
00208   <a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple;
00209 
00210   <span class="comment">/* check parameters */</span>
00211   <span class="keywordflow">if</span>( dim == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_ntuple_list: 'dim' must be positive."</span>);
00212 
00213   <span class="comment">/* get memory for list structure */</span>
00214   n_tuple = (<a class="code" href="structntuple__list__s.html">ntuple_list</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structntuple__list__s.html">ntuple_list_s</a>) );
00215   <span class="keywordflow">if</span>( n_tuple == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00216 
00217   <span class="comment">/* initialize list */</span>
00218   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 0;
00219   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> = 1;
00220   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> = dim;
00221 
00222   <span class="comment">/* get memory for tuples */</span>
00223   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) malloc( dim*n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00224   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00225 
00226   <span class="keywordflow">return</span> n_tuple;
00227 }
00228 
00229 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00230 <span class="comment">/** Enlarge the allocated memory of an n-tuple list.</span>
00231 <span class="comment"> */</span>
<a name="l00232"></a><a class="code" href="lsd_8c.html#a17">00232</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a17">enlarge_ntuple_list</a>(<a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple)
00233 {
00234   <span class="comment">/* check parameters */</span>
00235   <span class="keywordflow">if</span>( n_tuple == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> == 0 )
00236     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"enlarge_ntuple_list: invalid n-tuple."</span>);
00237 
00238   <span class="comment">/* duplicate number of tuples */</span>
00239   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> *= 2;
00240 
00241   <span class="comment">/* realloc memory */</span>
00242   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) realloc( (<span class="keywordtype">void</span> *) n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>,
00243                       n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> * n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00244   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00245 }
00246 
00247 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00248 <span class="comment">/** Add a 5-tuple to an n-tuple list.</span>
00249 <span class="comment"> */</span>
<a name="l00250"></a><a class="code" href="lsd_8c.html#a18">00250</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a18">add_5tuple</a>( <a class="code" href="structntuple__list__s.html">ntuple_list</a> out, <span class="keywordtype">double</span> v1, <span class="keywordtype">double</span> v2,
00251                         <span class="keywordtype">double</span> v3, <span class="keywordtype">double</span> v4, <span class="keywordtype">double</span> v5 )
00252 {
00253   <span class="comment">/* check parameters */</span>
00254   <span class="keywordflow">if</span>( out == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"add_5tuple: invalid n-tuple input."</span>);
00255   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> != 5 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"add_5tuple: the n-tuple must be a 5-tuple."</span>);
00256 
00257   <span class="comment">/* if needed, alloc more tuples to 'out' */</span>
00258   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> == out-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> ) <a class="code" href="lsd_8c.html#a17">enlarge_ntuple_list</a>(out);
00259   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"add_5tuple: invalid n-tuple input."</span>);
00260 
00261   <span class="comment">/* add new 5-tuple */</span>
00262   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 0 ] = v1;
00263   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 1 ] = v2;
00264   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 2 ] = v3;
00265   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 3 ] = v4;
00266   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 4 ] = v5;
00267 
00268   <span class="comment">/* update number of tuples counter */</span>
00269   out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>++;
00270 }
00271 
00272 
00273 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00274 <span class="comment">/*----------------------------- Image Data Types -----------------------------*/</span>
00275 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00276 
00277 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00278 <span class="comment">/** Free memory used in image_char 'i'.</span>
00279 <span class="comment"> */</span>
<a name="l00280"></a><a class="code" href="lsd_8c.html#a19">00280</a> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a19">free_image_char</a>(<a class="code" href="structimage__char__s.html">image_char</a> i)
00281 {
00282   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00283     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_image_char: invalid input image."</span>);
00284   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> );
00285   free( (<span class="keywordtype">void</span> *) i );
00286 }
00287 
00288 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00289 <span class="comment">/** Create a new image_char of size 'xsize' times 'ysize'.</span>
00290 <span class="comment"> */</span>
<a name="l00291"></a><a class="code" href="lsd_8c.html#a20">00291</a> <a class="code" href="structimage__char__s.html">image_char</a> <a class="code" href="lsd_8c.html#a20">new_image_char</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize)
00292 {
00293   <a class="code" href="structimage__char__s.html">image_char</a> image;
00294 
00295   <span class="comment">/* check parameters */</span>
00296   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_char: invalid image size."</span>);
00297 
00298   <span class="comment">/* get memory */</span>
00299   image = (<a class="code" href="structimage__char__s.html">image_char</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__char__s.html">image_char_s</a>) );
00300   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00301   image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) calloc( (size_t) (xsize*ysize),
00302                                           <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) );
00303   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00304 
00305   <span class="comment">/* set image size */</span>
00306   image-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> = xsize;
00307   image-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> = ysize;
00308 
00309   <span class="keywordflow">return</span> image;
00310 }
00311 
00312 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00313 <span class="comment">/** Create a new image_char of size 'xsize' times 'ysize',</span>
00314 <span class="comment">    initialized to the value 'fill_value'.</span>
00315 <span class="comment"> */</span>
<a name="l00316"></a><a class="code" href="lsd_8c.html#a21">00316</a> <a class="code" href="structimage__char__s.html">image_char</a> <a class="code" href="lsd_8c.html#a21">new_image_char_ini</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize,
00317                                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fill_value )
00318 {
00319   <a class="code" href="structimage__char__s.html">image_char</a> image = <a class="code" href="lsd_8c.html#a20">new_image_char</a>(xsize,ysize); <span class="comment">/* create image */</span>
00320   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00321   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00322 
00323   <span class="comment">/* check parameters */</span>
00324   <span class="keywordflow">if</span>( image == NULL || image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00325     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_char_ini: invalid image."</span>);
00326 
00327   <span class="comment">/* initialize */</span>
00328   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[i] = fill_value;
00329 
00330   <span class="keywordflow">return</span> image;
00331 }
00332 
00333 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00334 <span class="comment">/** Free memory used in image_int 'i'.</span>
00335 <span class="comment"> */</span>
<a name="l00336"></a><a class="code" href="lsd_8c.html#a22">00336</a> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a22">free_image_int</a>(<a class="code" href="structimage__int__s.html">image_int</a> i)
00337 {
00338   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL )
00339     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_image_int: invalid input image."</span>);
00340   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> );
00341   free( (<span class="keywordtype">void</span> *) i );
00342 }
00343 
00344 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00345 <span class="comment">/** Create a new image_int of size 'xsize' times 'ysize'.</span>
00346 <span class="comment"> */</span>
<a name="l00347"></a><a class="code" href="lsd_8c.html#a23">00347</a> <a class="code" href="structimage__int__s.html">image_int</a> <a class="code" href="lsd_8c.html#a23">new_image_int</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize)
00348 {
00349   <a class="code" href="structimage__int__s.html">image_int</a> image;
00350 
00351   <span class="comment">/* check parameters */</span>
00352   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_int: invalid image size."</span>);
00353 
00354   <span class="comment">/* get memory */</span>
00355   image = (<a class="code" href="structimage__int__s.html">image_int</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__int__s.html">image_int_s</a>) );
00356   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00357   image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> = (<span class="keywordtype">int</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) );
00358   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00359 
00360   <span class="comment">/* set image size */</span>
00361   image-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> = xsize;
00362   image-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a> = ysize;
00363 
00364   <span class="keywordflow">return</span> image;
00365 }
00366 
00367 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00368 <span class="comment">/** Create a new image_int of size 'xsize' times 'ysize',</span>
00369 <span class="comment">    initialized to the value 'fill_value'.</span>
00370 <span class="comment"> */</span>
<a name="l00371"></a><a class="code" href="lsd_8c.html#a24">00371</a> <a class="code" href="structimage__int__s.html">image_int</a> <a class="code" href="lsd_8c.html#a24">new_image_int_ini</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize,
00372                              <span class="keywordtype">int</span> fill_value )
00373 {
00374   <a class="code" href="structimage__int__s.html">image_int</a> image = <a class="code" href="lsd_8c.html#a23">new_image_int</a>(xsize,ysize); <span class="comment">/* create image */</span>
00375   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00376   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00377 
00378   <span class="comment">/* initialize */</span>
00379   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[i] = fill_value;
00380 
00381   <span class="keywordflow">return</span> image;
00382 }
00383 
00384 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00385 <span class="comment">/** Free memory used in image_double 'i'.</span>
00386 <span class="comment"> */</span>
<a name="l00387"></a><a class="code" href="lsd_8c.html#a25">00387</a> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a25">free_image_double</a>(<a class="code" href="structimage__double__s.html">image_double</a> i)
00388 {
00389   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00390     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"free_image_double: invalid input image."</span>);
00391   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> );
00392   free( (<span class="keywordtype">void</span> *) i );
00393 }
00394 
00395 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00396 <span class="comment">/** Create a new image_double of size 'xsize' times 'ysize'.</span>
00397 <span class="comment"> */</span>
<a name="l00398"></a><a class="code" href="lsd_8c.html#a26">00398</a> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a26">new_image_double</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize)
00399 {
00400   <a class="code" href="structimage__double__s.html">image_double</a> image;
00401 
00402   <span class="comment">/* check parameters */</span>
00403   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"new_image_double: invalid image size."</span>);
00404 
00405   <span class="comment">/* get memory */</span>
00406   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00407   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00408   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = (<span class="keywordtype">double</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00409   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00410 
00411   <span class="comment">/* set image size */</span>
00412   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00413   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00414 
00415   <span class="keywordflow">return</span> image;
00416 }
00417 
00418 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00419 <span class="comment">/** Create a new image_double of size 'xsize' times 'ysize',</span>
00420 <span class="comment">    initialized to the value 'fill_value'.</span>
00421 <span class="comment"> */</span>
<a name="l00422"></a><a class="code" href="lsd_8c.html#a27">00422</a> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a27">new_image_double_ini</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize,
00423                                    <span class="keywordtype">double</span> fill_value )
00424 {
00425   <a class="code" href="structimage__double__s.html">image_double</a> image = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(xsize,ysize); <span class="comment">/* create image */</span>
00426   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00427   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00428 
00429   <span class="comment">/* initialize */</span>
00430   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[i] = fill_value;
00431 
00432   <span class="keywordflow">return</span> image;
00433 }
00434 
00435 
00436 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00437 <span class="comment">/*----------------------------- Gaussian filter ------------------------------*/</span>
00438 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00439 
00440 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00441 <span class="comment">/** Compute a Gaussian kernel of length 'kernel-&gt;dim',</span>
00442 <span class="comment">    standard deviation 'sigma', and centered at value 'mean'.</span>
00443 <span class="comment"></span>
00444 <span class="comment">    For example, if mean=0.5, the Gaussian will be centered</span>
00445 <span class="comment">    in the middle point between values 'kernel-&gt;values[0]'</span>
00446 <span class="comment">    and 'kernel-&gt;values[1]'.</span>
00447 <span class="comment"> */</span>
<a name="l00448"></a><a class="code" href="lsd_8c.html#a28">00448</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a28">gaussian_kernel</a>(<a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> mean)
00449 {
00450   <span class="keywordtype">double</span> sum = 0.0;
00451   <span class="keywordtype">double</span> val;
00452   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00453 
00454   <span class="comment">/* check parameters */</span>
00455   <span class="keywordflow">if</span>( kernel == NULL || kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00456     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_kernel: invalid n-tuple 'kernel'."</span>);
00457   <span class="keywordflow">if</span>( sigma &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_kernel: 'sigma' must be positive."</span>);
00458 
00459   <span class="comment">/* compute Gaussian kernel */</span>
00460   <span class="keywordflow">if</span>( kernel-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> &lt; 1 ) <a class="code" href="lsd_8c.html#a17">enlarge_ntuple_list</a>(kernel);
00461   kernel-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 1;
00462   <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00463     {
00464       val = ( (<span class="keywordtype">double</span>) i - mean ) / sigma;
00465       kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] = exp( -0.5 * val * val );
00466       sum += kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00467     }
00468 
00469   <span class="comment">/* normalization */</span>
00470   <span class="keywordflow">if</span>( sum &gt;= 0.0 ) <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++) kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] /= sum;
00471 }
00472 
00473 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00474 <span class="comment">/** Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling.</span>
00475 <span class="comment"></span>
00476 <span class="comment">    For example, scale=0.8 will give a result at 80% of the original size.</span>
00477 <span class="comment"></span>
00478 <span class="comment">    The image is convolved with a Gaussian kernel</span>
00479 <span class="comment">    @f[</span>
00480 <span class="comment">        G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}}</span>
00481 <span class="comment">    @f]</span>
00482 <span class="comment">    before the sub-sampling to prevent aliasing.</span>
00483 <span class="comment"></span>
00484 <span class="comment">    The standard deviation sigma given by:</span>
00485 <span class="comment">    -  sigma = sigma_scale / scale,   if scale &lt;  1.0</span>
00486 <span class="comment">    -  sigma = sigma_scale,           if scale &gt;= 1.0</span>
00487 <span class="comment"></span>
00488 <span class="comment">    To be able to sub-sample at non-integer steps, some interpolation</span>
00489 <span class="comment">    is needed. In this implementation, the interpolation is done by</span>
00490 <span class="comment">    the Gaussian kernel, so both operations (filtering and sampling)</span>
00491 <span class="comment">    are done at the same time. The Gaussian kernel is computed</span>
00492 <span class="comment">    centered on the coordinates of the required sample. In this way,</span>
00493 <span class="comment">    when applied, it gives directly the result of convolving the image</span>
00494 <span class="comment">    with the kernel and interpolated to that particular position.</span>
00495 <span class="comment"></span>
00496 <span class="comment">    A fast algorithm is done using the separability of the Gaussian</span>
00497 <span class="comment">    kernel. Applying the 2D Gaussian kernel is equivalent to applying</span>
00498 <span class="comment">    first a horizontal 1D Gaussian kernel and then a vertical 1D</span>
00499 <span class="comment">    Gaussian kernel (or the other way round). The reason is that</span>
00500 <span class="comment">    @f[</span>
00501 <span class="comment">        G(x,y) = G(x) * G(y)</span>
00502 <span class="comment">    @f]</span>
00503 <span class="comment">    where</span>
00504 <span class="comment">    @f[</span>
00505 <span class="comment">        G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}.</span>
00506 <span class="comment">    @f]</span>
00507 <span class="comment">    The algorithm first apply a combined Gaussian kernel and sampling</span>
00508 <span class="comment">    in the x axis, and then the combined Gaussian kernel and sampling</span>
00509 <span class="comment">    in the y axis.</span>
00510 <span class="comment"> */</span>
<a name="l00511"></a><a class="code" href="lsd_8c.html#a29">00511</a> <span class="keyword">static</span> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a29">gaussian_sampler</a>( <a class="code" href="structimage__double__s.html">image_double</a> in, <span class="keywordtype">double</span> scale,
00512                                       <span class="keywordtype">double</span> sigma_scale )
00513 {
00514   <a class="code" href="structimage__double__s.html">image_double</a> aux,out;
00515   <a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel;
00516   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N,M,h,n,x,y,i;
00517   <span class="keywordtype">int</span> xc,yc,j,double_x_size,double_y_size;
00518   <span class="keywordtype">double</span> sigma,xx,yy,sum,prec;
00519 
00520   <span class="comment">/* check parameters */</span>
00521   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00522     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: invalid image."</span>);
00523   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: 'scale' must be positive."</span>);
00524   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 )
00525     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: 'sigma_scale' must be positive."</span>);
00526 
00527   <span class="comment">/* get memory for images */</span>
00528   <span class="keywordflow">if</span>( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX ||
00529       in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX )
00530     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"gaussian_sampler: the output image size exceeds the handled size."</span>);
00531   N = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) floor( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale );
00532   M = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) floor( in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale );
00533   aux = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(N,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00534   out = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(N,M);
00535 
00536   <span class="comment">/* sigma, kernel size and memory for the kernel */</span>
00537   sigma = scale &lt; 1.0 ? sigma_scale / scale : sigma_scale;
00538   <span class="comment">/*</span>
00539 <span class="comment">     The size of the kernel is selected to guarantee that the</span>
00540 <span class="comment">     the first discarded term is at least 10^prec times smaller</span>
00541 <span class="comment">     than the central value. For that, h should be larger than x, with</span>
00542 <span class="comment">       e^(-x^2/2sigma^2) = 1/10^prec.</span>
00543 <span class="comment">     Then,</span>
00544 <span class="comment">       x = sigma * sqrt( 2 * prec * ln(10) ).</span>
00545 <span class="comment">   */</span>
00546   prec = 3.0;
00547   h = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( sigma * sqrt( 2.0 * prec * log(10.0) ) );
00548   n = 1+2*h; <span class="comment">/* kernel size */</span>
00549   kernel = <a class="code" href="lsd_8c.html#a16">new_ntuple_list</a>(n);
00550 
00551   <span class="comment">/* auxiliary double image size variables */</span>
00552   double_x_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>);
00553   double_y_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00554 
00555   <span class="comment">/* First subsampling: x axis */</span>
00556   <span class="keywordflow">for</span>(x=0;x&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00557     {
00558       <span class="comment">/*</span>
00559 <span class="comment">         x   is the coordinate in the new image.</span>
00560 <span class="comment">         xx  is the corresponding x-value in the original size image.</span>
00561 <span class="comment">         xc  is the integer value, the pixel coordinate of xx.</span>
00562 <span class="comment">       */</span>
00563       xx = (<span class="keywordtype">double</span>) x / scale;
00564       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00565 <span class="comment">         so the pixel with xc=0 get the values of xx from -0.5 to 0.5 */</span>
00566       xc = (<span class="keywordtype">int</span>) floor( xx + 0.5 );
00567       <a class="code" href="lsd_8c.html#a28">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + xx - (<span class="keywordtype">double</span>) xc );
00568       <span class="comment">/* the kernel must be computed for each x because the fine</span>
00569 <span class="comment">         offset xx-xc is different in each case */</span>
00570 
00571       <span class="keywordflow">for</span>(y=0;y&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00572         {
00573           sum = 0.0;
00574           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00575             {
00576               j = xc - h + i;
00577 
00578               <span class="comment">/* symmetry boundary condition */</span>
00579               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_x_size;
00580               <span class="keywordflow">while</span>( j &gt;= double_x_size ) j -= double_x_size;
00581               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ) j = double_x_size-1-j;
00582 
00583               sum += in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ j + y * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00584             }
00585           aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00586         }
00587     }
00588 
00589   <span class="comment">/* Second subsampling: y axis */</span>
00590   <span class="keywordflow">for</span>(y=0;y&lt;out-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00591     {
00592       <span class="comment">/*</span>
00593 <span class="comment">         y   is the coordinate in the new image.</span>
00594 <span class="comment">         yy  is the corresponding x-value in the original size image.</span>
00595 <span class="comment">         yc  is the integer value, the pixel coordinate of xx.</span>
00596 <span class="comment">       */</span>
00597       yy = (<span class="keywordtype">double</span>) y / scale;
00598       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00599 <span class="comment">         so the pixel with yc=0 get the values of yy from -0.5 to 0.5 */</span>
00600       yc = (<span class="keywordtype">int</span>) floor( yy + 0.5 );
00601       <a class="code" href="lsd_8c.html#a28">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + yy - (<span class="keywordtype">double</span>) yc );
00602       <span class="comment">/* the kernel must be computed for each y because the fine</span>
00603 <span class="comment">         offset yy-yc is different in each case */</span>
00604 
00605       <span class="keywordflow">for</span>(x=0;x&lt;out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00606         {
00607           sum = 0.0;
00608           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00609             {
00610               j = yc - h + i;
00611 
00612               <span class="comment">/* symmetry boundary condition */</span>
00613               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_y_size;
00614               <span class="keywordflow">while</span>( j &gt;= double_y_size ) j -= double_y_size;
00615               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> ) j = double_y_size-1-j;
00616 
00617               sum += aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + j * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00618             }
00619           out-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00620         }
00621     }
00622 
00623   <span class="comment">/* free memory */</span>
00624   <a class="code" href="lsd_8c.html#a15">free_ntuple_list</a>(kernel);
00625   <a class="code" href="lsd_8c.html#a25">free_image_double</a>(aux);
00626 
00627   <span class="keywordflow">return</span> out;
00628 }
00629 
00630 
00631 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00632 <span class="comment">/*--------------------------------- Gradient ---------------------------------*/</span>
00633 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00634 
00635 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00636 <span class="comment">/** Computes the direction of the level line of 'in' at each point.</span>
00637 <span class="comment"></span>
00638 <span class="comment">    The result is:</span>
00639 <span class="comment">    - an image_double with the angle at each pixel, or NOTDEF if not defined.</span>
00640 <span class="comment">    - the image_double 'modgrad' (a pointer is passed as argument)</span>
00641 <span class="comment">      with the gradient magnitude at each point.</span>
00642 <span class="comment">    - a list of pixels 'list_p' roughly ordered by decreasing</span>
00643 <span class="comment">      gradient magnitude. (The order is made by classifying points</span>
00644 <span class="comment">      into bins by gradient magnitude. The parameters 'n_bins' and</span>
00645 <span class="comment">      'max_grad' specify the number of bins and the gradient modulus</span>
00646 <span class="comment">      at the highest bin. The pixels in the list would be in</span>
00647 <span class="comment">      decreasing gradient magnitude, up to a precision of the size of</span>
00648 <span class="comment">      the bins.)</span>
00649 <span class="comment">    - a pointer 'mem_p' to the memory used by 'list_p' to be able to</span>
00650 <span class="comment">      free the memory when it is not used anymore.</span>
00651 <span class="comment"> */</span>
<a name="l00652"></a><a class="code" href="lsd_8c.html#a30">00652</a> <span class="keyword">static</span> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a30">ll_angle</a>( <a class="code" href="structimage__double__s.html">image_double</a> in, <span class="keywordtype">double</span> threshold,
00653                               <span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> ** list_p, <span class="keywordtype">void</span> ** mem_p,
00654                               <a class="code" href="structimage__double__s.html">image_double</a> * modgrad, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_bins,
00655                               <span class="keywordtype">double</span> max_grad )
00656 {
00657   <a class="code" href="structimage__double__s.html">image_double</a> g;
00658   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,p,x,y,adr,i;
00659   <span class="keywordtype">double</span> com1,com2,gx,gy,norm,norm2;
00660   <span class="comment">/* the rest of the variables are used for pseudo-ordering</span>
00661 <span class="comment">     the gradient magnitude values */</span>
00662   <span class="keywordtype">int</span> list_count = 0;
00663   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list;
00664   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_s; <span class="comment">/* array of pointers to start of bin list */</span>
00665   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_e; <span class="comment">/* array of pointers to end of bin list */</span>
00666   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * start;
00667   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * end;
00668 
00669   <span class="comment">/* check parameters */</span>
00670   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00671     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: invalid image."</span>);
00672   <span class="keywordflow">if</span>( threshold &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: 'threshold' must be positive."</span>);
00673   <span class="keywordflow">if</span>( list_p == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'list_p'."</span>);
00674   <span class="keywordflow">if</span>( mem_p == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'mem_p'."</span>);
00675   <span class="keywordflow">if</span>( modgrad == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'modgrad'."</span>);
00676   <span class="keywordflow">if</span>( n_bins == 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: 'n_bins' must be positive."</span>);
00677   <span class="keywordflow">if</span>( max_grad &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ll_angle: 'max_grad' must be positive."</span>);
00678 
00679   <span class="comment">/* image size shortcuts */</span>
00680   n = in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
00681   p = in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
00682 
00683   <span class="comment">/* allocate output image */</span>
00684   g = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00685 
00686   <span class="comment">/* get memory for the image of gradient modulus */</span>
00687   *modgrad = <a class="code" href="lsd_8c.html#a26">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00688 
00689   <span class="comment">/* get memory for "ordered" list of pixels */</span>
00690   list = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> *) calloc( (size_t) (n*p), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a>) );
00691   *mem_p = (<span class="keywordtype">void</span> *) list;
00692   range_l_s = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00693                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00694   range_l_e = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00695                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00696   <span class="keywordflow">if</span>( list == NULL || range_l_s == NULL || range_l_e == NULL )
00697     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory."</span>);
00698   <span class="keywordflow">for</span>(i=0;i&lt;n_bins;i++) range_l_s[i] = range_l_e[i] = NULL;
00699 
00700   <span class="comment">/* 'undefined' on the down and right boundaries */</span>
00701   <span class="keywordflow">for</span>(x=0;x&lt;p;x++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[(n-1)*p+x] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00702   <span class="keywordflow">for</span>(y=0;y&lt;n;y++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[p*y+p-1]   = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00703 
00704   <span class="comment">/* compute gradient on the remaining pixels */</span>
00705   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00706     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00707       {
00708         adr = y*p+x;
00709 
00710         <span class="comment">/*</span>
00711 <span class="comment">           Norm 2 computation using 2x2 pixel window:</span>
00712 <span class="comment">             A B</span>
00713 <span class="comment">             C D</span>
00714 <span class="comment">           and</span>
00715 <span class="comment">             com1 = D-A,  com2 = B-C.</span>
00716 <span class="comment">           Then</span>
00717 <span class="comment">             gx = B+D - (A+C)   horizontal difference</span>
00718 <span class="comment">             gy = C+D - (A+B)   vertical difference</span>
00719 <span class="comment">           com1 and com2 are just to avoid 2 additions.</span>
00720 <span class="comment">         */</span>
00721         com1 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p+1] - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr];
00722         com2 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+1]   - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p];
00723 
00724         gx = com1+com2; <span class="comment">/* gradient x component */</span>
00725         gy = com1-com2; <span class="comment">/* gradient y component */</span>
00726         norm2 = gx*gx+gy*gy;
00727         norm = sqrt( norm2 / 4.0 ); <span class="comment">/* gradient norm */</span>
00728 
00729         (*modgrad)-&gt;data[adr] = norm; <span class="comment">/* store gradient norm */</span>
00730 
00731         <span class="keywordflow">if</span>( norm &lt;= threshold ) <span class="comment">/* norm too small, gradient no defined */</span>
00732           g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>; <span class="comment">/* gradient angle not defined */</span>
00733         <span class="keywordflow">else</span>
00734           {
00735             <span class="comment">/* gradient angle computation */</span>
00736             g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = atan2(gx,-gy);
00737 
00738             <span class="comment">/* store the point in the right bin according to its norm */</span>
00739             i = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (norm * (<span class="keywordtype">double</span>) n_bins / max_grad);
00740             <span class="keywordflow">if</span>( i &gt;= n_bins ) i = n_bins-1;
00741             <span class="keywordflow">if</span>( range_l_e[i] == NULL )
00742               range_l_s[i] = range_l_e[i] = list+list_count++;
00743             <span class="keywordflow">else</span>
00744               {
00745                 range_l_e[i]-&gt;next = list+list_count;
00746                 range_l_e[i] = list+list_count++;
00747               }
00748             range_l_e[i]-&gt;x = (<span class="keywordtype">int</span>) x;
00749             range_l_e[i]-&gt;y = (<span class="keywordtype">int</span>) y;
00750             range_l_e[i]-&gt;next = NULL;
00751           }
00752       }
00753 
00754   <span class="comment">/* Make the list of pixels (almost) ordered by norm value.</span>
00755 <span class="comment">     It starts by the larger bin, so the list starts by the</span>
00756 <span class="comment">     pixels with higher gradient value. Pixels would be ordered</span>
00757 <span class="comment">     by norm value, up to a precision given by max_grad/n_bins.</span>
00758 <span class="comment">   */</span>
00759   <span class="keywordflow">for</span>(i=n_bins-1; i&gt;0 &amp;&amp; range_l_s[i]==NULL; i--);
00760   start = range_l_s[i];
00761   end = range_l_e[i];
00762   <span class="keywordflow">if</span>( start != NULL )
00763     <span class="keywordflow">for</span>(i--;i&gt;0; i--)
00764       <span class="keywordflow">if</span>( range_l_s[i] != NULL )
00765         {
00766           end-&gt;next = range_l_s[i];
00767           end = range_l_e[i];
00768         }
00769   *list_p = start;
00770 
00771   <span class="comment">/* free memory */</span>
00772   free( (<span class="keywordtype">void</span> *) range_l_s );
00773   free( (<span class="keywordtype">void</span> *) range_l_e );
00774 
00775   <span class="keywordflow">return</span> g;
00776 }
00777 
00778 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00779 <span class="comment">/** Is point (x,y) aligned to angle theta, up to precision 'prec'?</span>
00780 <span class="comment"> */</span>
<a name="l00781"></a><a class="code" href="lsd_8c.html#a31">00781</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a31">isaligned</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keywordtype">double</span> theta,
00782                       <span class="keywordtype">double</span> prec )
00783 {
00784   <span class="keywordtype">double</span> a;
00785 
00786   <span class="comment">/* check parameters */</span>
00787   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00788     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"isaligned: invalid image 'angles'."</span>);
00789   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
00790     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"isaligned: (x,y) out of the image."</span>);
00791   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"isaligned: 'prec' must be positive."</span>);
00792 
00793   <span class="comment">/* angle at pixel (x,y) */</span>
00794   a = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
00795 
00796   <span class="comment">/* pixels whose level-line angle is not defined</span>
00797 <span class="comment">     are considered as NON-aligned */</span>
00798   <span class="keywordflow">if</span>( a == <a class="code" href="lsd_8c.html#a4">NOTDEF</a> ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;  <span class="comment">/* there is no need to call the function</span>
00799 <span class="comment">                                      'double_equal' here because there is</span>
00800 <span class="comment">                                      no risk of problems related to the</span>
00801 <span class="comment">                                      comparison doubles, we are only</span>
00802 <span class="comment">                                      interested in the exact NOTDEF value */</span>
00803 
00804   <span class="comment">/* it is assumed that 'theta' and 'a' are in the range [-pi,pi] */</span>
00805   theta -= a;
00806   <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00807   <span class="keywordflow">if</span>( theta &gt; <a class="code" href="lsd_8c.html#a5">M_3_2_PI</a> )
00808     {
00809       theta -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00810       <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00811     }
00812 
00813   <span class="keywordflow">return</span> theta &lt; prec;
00814 }
00815 
00816 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00817 <span class="comment">/** Absolute value angle difference.</span>
00818 <span class="comment"> */</span>
<a name="l00819"></a><a class="code" href="lsd_8c.html#a32">00819</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a32">angle_diff</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
00820 {
00821   a -= b;
00822   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00823   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00824   <span class="keywordflow">if</span>( a &lt; 0.0 ) a = -a;
00825   <span class="keywordflow">return</span> a;
00826 }
00827 
00828 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00829 <span class="comment">/** Signed angle difference.</span>
00830 <span class="comment"> */</span>
<a name="l00831"></a><a class="code" href="lsd_8c.html#a33">00831</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a33">angle_diff_signed</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
00832 {
00833   a -= b;
00834   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00835   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00836   <span class="keywordflow">return</span> a;
00837 }
00838 
00839 
00840 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00841 <span class="comment">/*----------------------------- NFA computation ------------------------------*/</span>
00842 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00843 
00844 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00845 <span class="comment">/** Computes the natural logarithm of the absolute value of</span>
00846 <span class="comment">    the gamma function of x using the Lanczos approximation.</span>
00847 <span class="comment">    See http://www.rskey.org/gamma.htm</span>
00848 <span class="comment"></span>
00849 <span class="comment">    The formula used is</span>
00850 <span class="comment">    @f[</span>
00851 <span class="comment">      \Gamma(x) = \frac{ \sum_{n=0}^{N} q_n x^n }{ \Pi_{n=0}^{N} (x+n) }</span>
00852 <span class="comment">                  (x+5.5)^{x+0.5} e^{-(x+5.5)}</span>
00853 <span class="comment">    @f]</span>
00854 <span class="comment">    so</span>
00855 <span class="comment">    @f[</span>
00856 <span class="comment">      \log\Gamma(x) = \log\left( \sum_{n=0}^{N} q_n x^n \right)</span>
00857 <span class="comment">                      + (x+0.5) \log(x+5.5) - (x+5.5) - \sum_{n=0}^{N} \log(x+n)</span>
00858 <span class="comment">    @f]</span>
00859 <span class="comment">    and</span>
00860 <span class="comment">      q0 = 75122.6331530,</span>
00861 <span class="comment">      q1 = 80916.6278952,</span>
00862 <span class="comment">      q2 = 36308.2951477,</span>
00863 <span class="comment">      q3 = 8687.24529705,</span>
00864 <span class="comment">      q4 = 1168.92649479,</span>
00865 <span class="comment">      q5 = 83.8676043424,</span>
00866 <span class="comment">      q6 = 2.50662827511.</span>
00867 <span class="comment"> */</span>
<a name="l00868"></a><a class="code" href="lsd_8c.html#a34">00868</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a34">log_gamma_lanczos</a>(<span class="keywordtype">double</span> x)
00869 {
00870   <span class="keyword">static</span> <span class="keywordtype">double</span> q[7] = { 75122.6331530, 80916.6278952, 36308.2951477,
00871                          8687.24529705, 1168.92649479, 83.8676043424,
00872                          2.50662827511 };
00873   <span class="keywordtype">double</span> a = (x+0.5) * log(x+5.5) - (x+5.5);
00874   <span class="keywordtype">double</span> b = 0.0;
00875   <span class="keywordtype">int</span> n;
00876 
00877   <span class="keywordflow">for</span>(n=0;n&lt;7;n++)
00878     {
00879       a -= log( x + (<span class="keywordtype">double</span>) n );
00880       b += q[n] * pow( x, (<span class="keywordtype">double</span>) n );
00881     }
00882   <span class="keywordflow">return</span> a + log(b);
00883 }
00884 
00885 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00886 <span class="comment">/** Computes the natural logarithm of the absolute value of</span>
00887 <span class="comment">    the gamma function of x using Windschitl method.</span>
00888 <span class="comment">    See http://www.rskey.org/gamma.htm</span>
00889 <span class="comment"></span>
00890 <span class="comment">    The formula used is</span>
00891 <span class="comment">    @f[</span>
00892 <span class="comment">        \Gamma(x) = \sqrt{\frac{2\pi}{x}} \left( \frac{x}{e}</span>
00893 <span class="comment">                    \sqrt{ x\sinh(1/x) + \frac{1}{810x^6} } \right)^x</span>
00894 <span class="comment">    @f]</span>
00895 <span class="comment">    so</span>
00896 <span class="comment">    @f[</span>
00897 <span class="comment">        \log\Gamma(x) = 0.5\log(2\pi) + (x-0.5)\log(x) - x</span>
00898 <span class="comment">                      + 0.5x\log\left( x\sinh(1/x) + \frac{1}{810x^6} \right).</span>
00899 <span class="comment">    @f]</span>
00900 <span class="comment">    This formula is a good approximation when x &gt; 15.</span>
00901 <span class="comment"> */</span>
<a name="l00902"></a><a class="code" href="lsd_8c.html#a35">00902</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a35">log_gamma_windschitl</a>(<span class="keywordtype">double</span> x)
00903 {
00904   <span class="keywordflow">return</span> 0.918938533204673 + (x-0.5)*log(x) - x
00905          + 0.5*x*log( x*sinh(1/x) + 1/(810.0*pow(x,6.0)) );
00906 }
00907 
00908 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00909 <span class="comment">/** Computes the natural logarithm of the absolute value of</span>
00910 <span class="comment">    the gamma function of x. When x&gt;15 use log_gamma_windschitl(),</span>
00911 <span class="comment">    otherwise use log_gamma_lanczos().</span>
00912 <span class="comment"> */</span>
<a name="l00913"></a><a class="code" href="lsd_8c.html#a10">00913</a> <span class="preprocessor">#define log_gamma(x) ((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))</span>
00914 <span class="preprocessor"></span>
00915 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00916 <span class="comment">/** Size of the table to store already computed inverse values.</span>
00917 <span class="comment"> */</span>
<a name="l00918"></a><a class="code" href="lsd_8c.html#a11">00918</a> <span class="preprocessor">#define TABSIZE 100000</span>
00919 <span class="preprocessor"></span>
00920 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00921 <span class="comment">/** Computes -log10(NFA).</span>
00922 <span class="comment"></span>
00923 <span class="comment">    NFA stands for Number of False Alarms:</span>
00924 <span class="comment">    @f[</span>
00925 <span class="comment">        \mathrm{NFA} = NT \cdot B(n,k,p)</span>
00926 <span class="comment">    @f]</span>
00927 <span class="comment"></span>
00928 <span class="comment">    - NT       - number of tests</span>
00929 <span class="comment">    - B(n,k,p) - tail of binomial distribution with parameters n,k and p:</span>
00930 <span class="comment">    @f[</span>
00931 <span class="comment">        B(n,k,p) = \sum_{j=k}^n</span>
00932 <span class="comment">                   \left(\begin{array}{c}n\\j\end{array}\right)</span>
00933 <span class="comment">                   p^{j} (1-p)^{n-j}</span>
00934 <span class="comment">    @f]</span>
00935 <span class="comment"></span>
00936 <span class="comment">    The value -log10(NFA) is equivalent but more intuitive than NFA:</span>
00937 <span class="comment">    - -1 corresponds to 10 mean false alarms</span>
00938 <span class="comment">    -  0 corresponds to 1 mean false alarm</span>
00939 <span class="comment">    -  1 corresponds to 0.1 mean false alarms</span>
00940 <span class="comment">    -  2 corresponds to 0.01 mean false alarms</span>
00941 <span class="comment">    -  ...</span>
00942 <span class="comment"></span>
00943 <span class="comment">    Used this way, the bigger the value, better the detection,</span>
00944 <span class="comment">    and a logarithmic scale is used.</span>
00945 <span class="comment"></span>
00946 <span class="comment">    @param n,k,p binomial parameters.</span>
00947 <span class="comment">    @param logNT logarithm of Number of Tests</span>
00948 <span class="comment"></span>
00949 <span class="comment">    The computation is based in the gamma function by the following</span>
00950 <span class="comment">    relation:</span>
00951 <span class="comment">    @f[</span>
00952 <span class="comment">        \left(\begin{array}{c}n\\k\end{array}\right)</span>
00953 <span class="comment">        = \frac{ \Gamma(n+1) }{ \Gamma(k+1) \cdot \Gamma(n-k+1) }.</span>
00954 <span class="comment">    @f]</span>
00955 <span class="comment">    We use efficient algorithms to compute the logarithm of</span>
00956 <span class="comment">    the gamma function.</span>
00957 <span class="comment"></span>
00958 <span class="comment">    To make the computation faster, not all the sum is computed, part</span>
00959 <span class="comment">    of the terms are neglected based on a bound to the error obtained</span>
00960 <span class="comment">    (an error of 10% in the result is accepted).</span>
00961 <span class="comment"> */</span>
<a name="l00962"></a><a class="code" href="lsd_8c.html#a36">00962</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a36">nfa</a>(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> k, <span class="keywordtype">double</span> p, <span class="keywordtype">double</span> logNT)
00963 {
00964   <span class="keyword">static</span> <span class="keywordtype">double</span> inv[<a class="code" href="lsd_8c.html#a11">TABSIZE</a>];   <span class="comment">/* table to keep computed inverse values */</span>
00965   <span class="keywordtype">double</span> tolerance = 0.1;       <span class="comment">/* an error of 10% in the result is accepted */</span>
00966   <span class="keywordtype">double</span> log1term,term,bin_term,mult_term,bin_tail,err,p_term;
00967   <span class="keywordtype">int</span> i;
00968 
00969   <span class="comment">/* check parameters */</span>
00970   <span class="keywordflow">if</span>( n&lt;0 || k&lt;0 || k&gt;n || p&lt;=0.0 || p&gt;=1.0 )
00971     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"nfa: wrong n, k or p values."</span>);
00972 
00973   <span class="comment">/* trivial cases */</span>
00974   <span class="keywordflow">if</span>( n==0 || k==0 ) <span class="keywordflow">return</span> -logNT;
00975   <span class="keywordflow">if</span>( n==k ) <span class="keywordflow">return</span> -logNT - (<span class="keywordtype">double</span>) n * log10(p);
00976 
00977   <span class="comment">/* probability term */</span>
00978   p_term = p / (1.0-p);
00979 
00980   <span class="comment">/* compute the first term of the series */</span>
00981   <span class="comment">/*</span>
00982 <span class="comment">     binomial_tail(n,k,p) = sum_{i=k}^n bincoef(n,i) * p^i * (1-p)^{n-i}</span>
00983 <span class="comment">     where bincoef(n,i) are the binomial coefficients.</span>
00984 <span class="comment">     But</span>
00985 <span class="comment">       bincoef(n,k) = gamma(n+1) / ( gamma(k+1) * gamma(n-k+1) ).</span>
00986 <span class="comment">     We use this to compute the first term. Actually the log of it.</span>
00987 <span class="comment">   */</span>
00988   log1term = <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) n + 1.0 ) - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) k + 1.0 )
00989            - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) (n-k) + 1.0 )
00990            + (<span class="keywordtype">double</span>) k * log(p) + (<span class="keywordtype">double</span>) (n-k) * log(1.0-p);
00991   term = exp(log1term);
00992 
00993   <span class="comment">/* in some cases no more computations are needed */</span>
00994   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(term,0.0) )              <span class="comment">/* the first term is almost zero */</span>
00995     {
00996       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) k &gt; (<span class="keywordtype">double</span>) n * p )     <span class="comment">/* at begin or end of the tail?  */</span>
00997         <span class="keywordflow">return</span> -log1term / <a class="code" href="lsd_8c.html#a0">M_LN10</a> - logNT;  <span class="comment">/* end: use just the first term  */</span>
00998       <span class="keywordflow">else</span>
00999         <span class="keywordflow">return</span> -logNT;                      <span class="comment">/* begin: the tail is roughly 1  */</span>
01000     }
01001 
01002   <span class="comment">/* compute more terms if needed */</span>
01003   bin_tail = term;
01004   <span class="keywordflow">for</span>(i=k+1;i&lt;=n;i++)
01005     {
01006       <span class="comment">/*</span>
01007 <span class="comment">         As</span>
01008 <span class="comment">           term_i = bincoef(n,i) * p^i * (1-p)^(n-i)</span>
01009 <span class="comment">         and</span>
01010 <span class="comment">           bincoef(n,i)/bincoef(n,i-1) = n-1+1 / i,</span>
01011 <span class="comment">         then,</span>
01012 <span class="comment">           term_i / term_i-1 = (n-i+1)/i * p/(1-p)</span>
01013 <span class="comment">         and</span>
01014 <span class="comment">           term_i = term_i-1 * (n-i+1)/i * p/(1-p).</span>
01015 <span class="comment">         1/i is stored in a table as they are computed,</span>
01016 <span class="comment">         because divisions are expensive.</span>
01017 <span class="comment">         p/(1-p) is computed only once and stored in 'p_term'.</span>
01018 <span class="comment">       */</span>
01019       bin_term = (<span class="keywordtype">double</span>) (n-i+1) * ( i&lt;<a class="code" href="lsd_8c.html#a11">TABSIZE</a> ?
01020                    ( inv[i]!=0.0 ? inv[i] : ( inv[i] = 1.0 / (<span class="keywordtype">double</span>) i ) ) :
01021                    1.0 / (<span class="keywordtype">double</span>) i );
01022 
01023       mult_term = bin_term * p_term;
01024       term *= mult_term;
01025       bin_tail += term;
01026       <span class="keywordflow">if</span>(bin_term&lt;1.0)
01027         {
01028           <span class="comment">/* When bin_term&lt;1 then mult_term_j&lt;mult_term_i for j&gt;i.</span>
01029 <span class="comment">             Then, the error on the binomial tail when truncated at</span>
01030 <span class="comment">             the i term can be bounded by a geometric series of form</span>
01031 <span class="comment">             term_i * sum mult_term_i^j.                            */</span>
01032           err = term * ( ( 1.0 - pow( mult_term, (<span class="keywordtype">double</span>) (n-i+1) ) ) /
01033                          (1.0-mult_term) - 1.0 );
01034 
01035           <span class="comment">/* One wants an error at most of tolerance*final_result, or:</span>
01036 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT).</span>
01037 <span class="comment">             Now, the error that can be accepted on bin_tail is</span>
01038 <span class="comment">             given by tolerance*final_result divided by the derivative</span>
01039 <span class="comment">             of -log10(x) when x=bin_tail. that is:</span>
01040 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) / (1/bin_tail)</span>
01041 <span class="comment">             Finally, we truncate the tail if the error is less than:</span>
01042 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) * bin_tail        */</span>
01043           <span class="keywordflow">if</span>( err &lt; tolerance * fabs(-log10(bin_tail)-logNT) * bin_tail ) <span class="keywordflow">break</span>;
01044         }
01045     }
01046   <span class="keywordflow">return</span> -log10(bin_tail) - logNT;
01047 }
01048 
01049 
01050 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01051 <span class="comment">/*--------------------------- Rectangle structure ----------------------------*/</span>
01052 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01053 
01054 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01055 <span class="comment">/** Rectangle structure: line segment with width.</span>
01056 <span class="comment"> */</span>
<a name="l01057"></a><a class="code" href="structrect.html">01057</a> <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a>
01058 {
<a name="l01059"></a><a class="code" href="structrect.html#o3">01059</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o0">x1</a>,<a class="code" href="structrect.html#o1">y1</a>,<a class="code" href="structrect.html#o2">x2</a>,<a class="code" href="structrect.html#o3">y2</a>;  <span class="comment">/* first and second point of the line segment */</span>
<a name="l01060"></a><a class="code" href="structrect.html#o4">01060</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o4">width</a>;        <span class="comment">/* rectangle width */</span>
<a name="l01061"></a><a class="code" href="structrect.html#o6">01061</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o5">x</a>,<a class="code" href="structrect.html#o6">y</a>;          <span class="comment">/* center of the rectangle */</span>
<a name="l01062"></a><a class="code" href="structrect.html#o7">01062</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o7">theta</a>;        <span class="comment">/* angle */</span>
<a name="l01063"></a><a class="code" href="structrect.html#o9">01063</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o8">dx</a>,<a class="code" href="structrect.html#o9">dy</a>;        <span class="comment">/* vector with the line segment angle */</span>
<a name="l01064"></a><a class="code" href="structrect.html#o10">01064</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o10">prec</a>;         <span class="comment">/* tolerance angle */</span>
<a name="l01065"></a><a class="code" href="structrect.html#o11">01065</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o11">p</a>;            <span class="comment">/* probability of a point with angle within 'prec' */</span>
01066 };
01067 
01068 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01069 <span class="comment">/** Copy one rectangle structure to another.</span>
01070 <span class="comment"> */</span>
<a name="l01071"></a><a class="code" href="lsd_8c.html#a37">01071</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a37">rect_copy</a>(<span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * in, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * out)
01072 {
01073   <span class="comment">/* check parameters */</span>
01074   <span class="keywordflow">if</span>( in == NULL || out == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"rect_copy: invalid 'in' or 'out'."</span>);
01075 
01076   <span class="comment">/* copy values */</span>
01077   out-&gt;<a class="code" href="structrect.html#o0">x1</a> = in-&gt;<a class="code" href="structrect.html#o0">x1</a>;
01078   out-&gt;<a class="code" href="structrect.html#o1">y1</a> = in-&gt;<a class="code" href="structrect.html#o1">y1</a>;
01079   out-&gt;<a class="code" href="structrect.html#o2">x2</a> = in-&gt;<a class="code" href="structrect.html#o2">x2</a>;
01080   out-&gt;<a class="code" href="structrect.html#o3">y2</a> = in-&gt;<a class="code" href="structrect.html#o3">y2</a>;
01081   out-&gt;<a class="code" href="structrect.html#o4">width</a> = in-&gt;<a class="code" href="structrect.html#o4">width</a>;
01082   out-&gt;<a class="code" href="structrect.html#o5">x</a> = in-&gt;<a class="code" href="structrect.html#o5">x</a>;
01083   out-&gt;<a class="code" href="structrect.html#o6">y</a> = in-&gt;<a class="code" href="structrect.html#o6">y</a>;
01084   out-&gt;<a class="code" href="structrect.html#o7">theta</a> = in-&gt;<a class="code" href="structrect.html#o7">theta</a>;
01085   out-&gt;<a class="code" href="structrect.html#o8">dx</a> = in-&gt;<a class="code" href="structrect.html#o8">dx</a>;
01086   out-&gt;<a class="code" href="structrect.html#o9">dy</a> = in-&gt;<a class="code" href="structrect.html#o9">dy</a>;
01087   out-&gt;<a class="code" href="structrect.html#o10">prec</a> = in-&gt;<a class="code" href="structrect.html#o10">prec</a>;
01088   out-&gt;<a class="code" href="structrect.html#o11">p</a> = in-&gt;<a class="code" href="structrect.html#o11">p</a>;
01089 }
01090 
01091 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01092 <span class="comment">/** Rectangle points iterator.</span>
01093 <span class="comment"></span>
01094 <span class="comment">    The integer coordinates of pixels inside a rectangle are</span>
01095 <span class="comment">    iteratively explored. This structure keep track of the process and</span>
01096 <span class="comment">    functions ri_ini(), ri_inc(), ri_end(), and ri_del() are used in</span>
01097 <span class="comment">    the process. An example of how to use the iterator is as follows:</span>
01098 <span class="comment">    \code</span>
01099 <span class="comment"></span>
01100 <span class="comment">      struct rect * rec = XXX; // some rectangle</span>
01101 <span class="comment">      rect_iter * i;</span>
01102 <span class="comment">      for( i=ri_ini(rec); !ri_end(i); ri_inc(i) )</span>
01103 <span class="comment">        {</span>
01104 <span class="comment">          // your code, using 'i-&gt;x' and 'i-&gt;y' as coordinates</span>
01105 <span class="comment">        }</span>
01106 <span class="comment">      ri_del(i); // delete iterator</span>
01107 <span class="comment"></span>
01108 <span class="comment">    \endcode</span>
01109 <span class="comment">    The pixels are explored 'column' by 'column', where we call</span>
01110 <span class="comment">    'column' a set of pixels with the same x value that are inside the</span>
01111 <span class="comment">    rectangle. The following is an schematic representation of a</span>
01112 <span class="comment">    rectangle, the 'column' being explored is marked by colons, and</span>
01113 <span class="comment">    the current pixel being explored is 'x,y'.</span>
01114 <span class="comment">    \verbatim</span>
01115 <span class="comment"></span>
01116 <span class="comment">              vx[1],vy[1]</span>
01117 <span class="comment">                 *   *</span>
01118 <span class="comment">                *       *</span>
01119 <span class="comment">               *           *</span>
01120 <span class="comment">              *               ye</span>
01121 <span class="comment">             *                :  *</span>
01122 <span class="comment">        vx[0],vy[0]           :     *</span>
01123 <span class="comment">               *              :        *</span>
01124 <span class="comment">                  *          x,y          *</span>
01125 <span class="comment">                     *        :              *</span>
01126 <span class="comment">                        *     :            vx[2],vy[2]</span>
01127 <span class="comment">                           *  :                *</span>
01128 <span class="comment">        y                     ys              *</span>
01129 <span class="comment">        ^                        *           *</span>
01130 <span class="comment">        |                           *       *</span>
01131 <span class="comment">        |                              *   *</span>
01132 <span class="comment">        +---&gt; x                      vx[3],vy[3]</span>
01133 <span class="comment"></span>
01134 <span class="comment">    \endverbatim</span>
01135 <span class="comment">    The first 'column' to be explored is the one with the smaller x</span>
01136 <span class="comment">    value. Each 'column' is explored starting from the pixel of the</span>
01137 <span class="comment">    'column' (inside the rectangle) with the smaller y value.</span>
01138 <span class="comment"></span>
01139 <span class="comment">    The four corners of the rectangle are stored in order that rotates</span>
01140 <span class="comment">    around the corners at the arrays 'vx[]' and 'vy[]'. The first</span>
01141 <span class="comment">    point is always the one with smaller x value.</span>
01142 <span class="comment"></span>
01143 <span class="comment">    'x' and 'y' are the coordinates of the pixel being explored. 'ys'</span>
01144 <span class="comment">    and 'ye' are the start and end values of the current column being</span>
01145 <span class="comment">    explored. So, 'ys' &lt; 'ye'.</span>
01146 <span class="comment"> */</span>
<a name="l01147"></a><a class="code" href="structrect__iter.html">01147</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
01148 <span class="keyword"></span>{
<a name="l01149"></a><a class="code" href="structrect__iter.html#o0">01149</a>   <span class="keywordtype">double</span> vx[4];  <span class="comment">/* rectangle's corner X coordinates in circular order */</span>
<a name="l01150"></a><a class="code" href="structrect__iter.html#o1">01150</a>   <span class="keywordtype">double</span> vy[4];  <span class="comment">/* rectangle's corner Y coordinates in circular order */</span>
<a name="l01151"></a><a class="code" href="structrect__iter.html#o2">01151</a>   <span class="keywordtype">double</span> ys,ye;  <span class="comment">/* start and end Y values of current 'column' */</span>
<a name="l01152"></a><a class="code" href="structrect__iter.html#o5">01152</a>   <span class="keywordtype">int</span> x,y;       <span class="comment">/* coordinates of currently explored pixel */</span>
01153 } <a class="code" href="structrect__iter.html">rect_iter</a>;
01154 
01155 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01156 <span class="comment">/** Interpolate y value corresponding to 'x' value given, in</span>
01157 <span class="comment">    the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller</span>
01158 <span class="comment">    of 'y1' and 'y2'.</span>
01159 <span class="comment"></span>
01160 <span class="comment">    The following restrictions are required:</span>
01161 <span class="comment">    - x1 &lt;= x2</span>
01162 <span class="comment">    - x1 &lt;= x</span>
01163 <span class="comment">    - x  &lt;= x2</span>
01164 <span class="comment"> */</span>
<a name="l01165"></a><a class="code" href="lsd_8c.html#a38">01165</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a38">inter_low</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> x1, <span class="keywordtype">double</span> y1, <span class="keywordtype">double</span> x2, <span class="keywordtype">double</span> y2)
01166 {
01167   <span class="comment">/* check parameters */</span>
01168   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01169     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"inter_low: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01170 
01171   <span class="comment">/* interpolation */</span>
01172   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y1;
01173   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y2;
01174   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01175 }
01176 
01177 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01178 <span class="comment">/** Interpolate y value corresponding to 'x' value given, in</span>
01179 <span class="comment">    the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger</span>
01180 <span class="comment">    of 'y1' and 'y2'.</span>
01181 <span class="comment"></span>
01182 <span class="comment">    The following restrictions are required:</span>
01183 <span class="comment">    - x1 &lt;= x2</span>
01184 <span class="comment">    - x1 &lt;= x</span>
01185 <span class="comment">    - x  &lt;= x2</span>
01186 <span class="comment"> */</span>
<a name="l01187"></a><a class="code" href="lsd_8c.html#a39">01187</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a39">inter_hi</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> x1, <span class="keywordtype">double</span> y1, <span class="keywordtype">double</span> x2, <span class="keywordtype">double</span> y2)
01188 {
01189   <span class="comment">/* check parameters */</span>
01190   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01191     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"inter_hi: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01192 
01193   <span class="comment">/* interpolation */</span>
01194   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y2;
01195   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y1;
01196   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01197 }
01198 
01199 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01200 <span class="comment">/** Free memory used by a rectangle iterator.</span>
01201 <span class="comment"> */</span>
<a name="l01202"></a><a class="code" href="lsd_8c.html#a40">01202</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a40">ri_del</a>(<a class="code" href="structrect__iter.html">rect_iter</a> * iter)
01203 {
01204   <span class="keywordflow">if</span>( iter == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_del: NULL iterator."</span>);
01205   free( (<span class="keywordtype">void</span> *) iter );
01206 }
01207 
01208 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01209 <span class="comment">/** Check if the iterator finished the full iteration.</span>
01210 <span class="comment"></span>
01211 <span class="comment">    See details in \ref rect_iter</span>
01212 <span class="comment"> */</span>
<a name="l01213"></a><a class="code" href="lsd_8c.html#a41">01213</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a41">ri_end</a>(<a class="code" href="structrect__iter.html">rect_iter</a> * i)
01214 {
01215   <span class="comment">/* check input */</span>
01216   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_end: NULL iterator."</span>);
01217 
01218   <span class="comment">/* if the current x value is larger than the larger</span>
01219 <span class="comment">     x value in the rectangle (vx[2]), we know the full</span>
01220 <span class="comment">     exploration of the rectangle is finished. */</span>
01221   <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2];
01222 }
01223 
01224 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01225 <span class="comment">/** Increment a rectangle iterator.</span>
01226 <span class="comment"></span>
01227 <span class="comment">    See details in \ref rect_iter</span>
01228 <span class="comment"> */</span>
<a name="l01229"></a><a class="code" href="lsd_8c.html#a42">01229</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a42">ri_inc</a>(<a class="code" href="structrect__iter.html">rect_iter</a> * i)
01230 {
01231   <span class="comment">/* check input */</span>
01232   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_inc: NULL iterator."</span>);
01233 
01234   <span class="comment">/* if not at end of exploration,</span>
01235 <span class="comment">     increase y value for next pixel in the 'column' */</span>
01236   <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a41">ri_end</a>(i) ) i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>++;
01237 
01238   <span class="comment">/* if the end of the current 'column' is reached,</span>
01239 <span class="comment">     and it is not the end of exploration,</span>
01240 <span class="comment">     advance to the next 'column' */</span>
01241   <span class="keywordflow">while</span>( (<span class="keywordtype">double</span>) (i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> &amp;&amp; !<a class="code" href="lsd_8c.html#a41">ri_end</a>(i) )
01242     {
01243       <span class="comment">/* increase x, next 'column' */</span>
01244       i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>++;
01245 
01246       <span class="comment">/* if end of exploration, return */</span>
01247       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a41">ri_end</a>(i) ) <span class="keywordflow">return</span>;
01248 
01249       <span class="comment">/* update lower y limit (start) for the new 'column'.</span>
01250 <span class="comment"></span>
01251 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01252 <span class="comment">         lower side of the rectangle. The first thing is to decide if</span>
01253 <span class="comment">         the corresponding side is</span>
01254 <span class="comment"></span>
01255 <span class="comment">           vx[0],vy[0] to vx[3],vy[3] or</span>
01256 <span class="comment">           vx[3],vy[3] to vx[2],vy[2]</span>
01257 <span class="comment"></span>
01258 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01259 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01260 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01261 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01262 <span class="comment">         by using 'inter_low'.</span>
01263 <span class="comment">       */</span>
01264       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3] )
01265         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a38">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3]);
01266       <span class="keywordflow">else</span>
01267         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a38">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01268 
01269       <span class="comment">/* update upper y limit (end) for the new 'column'.</span>
01270 <span class="comment"></span>
01271 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01272 <span class="comment">         upper side of the rectangle. The first thing is to decide if</span>
01273 <span class="comment">         the corresponding side is</span>
01274 <span class="comment"></span>
01275 <span class="comment">           vx[0],vy[0] to vx[1],vy[1] or</span>
01276 <span class="comment">           vx[1],vy[1] to vx[2],vy[2]</span>
01277 <span class="comment"></span>
01278 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01279 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01280 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01281 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01282 <span class="comment">         by using 'inter_low'.</span>
01283 <span class="comment">       */</span>
01284       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1] )
01285         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a39">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1]);
01286       <span class="keywordflow">else</span>
01287         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a39">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01288 
01289       <span class="comment">/* new y */</span>
01290       i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a>);
01291     }
01292 }
01293 
01294 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01295 <span class="comment">/** Create and initialize a rectangle iterator.</span>
01296 <span class="comment"></span>
01297 <span class="comment">    See details in \ref rect_iter</span>
01298 <span class="comment"> */</span>
<a name="l01299"></a><a class="code" href="lsd_8c.html#a43">01299</a> <span class="keyword">static</span> <a class="code" href="structrect__iter.html">rect_iter</a> * <a class="code" href="lsd_8c.html#a43">ri_ini</a>(<span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * r)
01300 {
01301   <span class="keywordtype">double</span> vx[4],vy[4];
01302   <span class="keywordtype">int</span> n,offset;
01303   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01304 
01305   <span class="comment">/* check parameters */</span>
01306   <span class="keywordflow">if</span>( r == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_ini: invalid rectangle."</span>);
01307 
01308   <span class="comment">/* get memory */</span>
01309   i = (<a class="code" href="structrect__iter.html">rect_iter</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structrect__iter.html">rect_iter</a>));
01310   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"ri_ini: Not enough memory."</span>);
01311 
01312   <span class="comment">/* build list of rectangle corners ordered</span>
01313 <span class="comment">     in a circular way around the rectangle */</span>
01314   vx[0] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01315   vy[0] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01316   vx[1] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01317   vy[1] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01318   vx[2] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01319   vy[2] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01320   vx[3] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01321   vy[3] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01322 
01323   <span class="comment">/* compute rotation of index of corners needed so that the first</span>
01324 <span class="comment">     point has the smaller x.</span>
01325 <span class="comment"></span>
01326 <span class="comment">     if one side is vertical, thus two corners have the same smaller x</span>
01327 <span class="comment">     value, the one with the largest y value is selected as the first.</span>
01328 <span class="comment">   */</span>
01329   <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &lt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 0;
01330   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt; r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 1;
01331   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 2;
01332   <span class="keywordflow">else</span> offset = 3;
01333 
01334   <span class="comment">/* apply rotation of index. */</span>
01335   <span class="keywordflow">for</span>(n=0; n&lt;4; n++)
01336     {
01337       i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[n] = vx[(offset+n)%4];
01338       i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[n] = vy[(offset+n)%4];
01339     }
01340 
01341   <span class="comment">/* Set a initial condition.</span>
01342 <span class="comment"></span>
01343 <span class="comment">     The values are set to values that will cause 'ri_inc' (that will</span>
01344 <span class="comment">     be called immediately) to initialize correctly the first 'column'</span>
01345 <span class="comment">     and compute the limits 'ys' and 'ye'.</span>
01346 <span class="comment"></span>
01347 <span class="comment">     'y' is set to the integer value of vy[0], the starting corner.</span>
01348 <span class="comment"></span>
01349 <span class="comment">     'ys' and 'ye' are set to very small values, so 'ri_inc' will</span>
01350 <span class="comment">     notice that it needs to start a new 'column'.</span>
01351 <span class="comment"></span>
01352 <span class="comment">     The smaller integer coordinate inside of the rectangle is</span>
01353 <span class="comment">     'ceil(vx[0])'. The current 'x' value is set to that value minus</span>
01354 <span class="comment">     one, so 'ri_inc' (that will increase x by one) will advance to</span>
01355 <span class="comment">     the first 'column'.</span>
01356 <span class="comment">   */</span>
01357   i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0]) - 1;
01358   i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0]);
01359   i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = -DBL_MAX;
01360 
01361   <span class="comment">/* advance to the first pixel */</span>
01362   <a class="code" href="lsd_8c.html#a42">ri_inc</a>(i);
01363 
01364   <span class="keywordflow">return</span> i;
01365 }
01366 
01367 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01368 <span class="comment">/** Compute a rectangle's NFA value.</span>
01369 <span class="comment"> */</span>
<a name="l01370"></a><a class="code" href="lsd_8c.html#a44">01370</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(<span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keywordtype">double</span> logNT)
01371 {
01372   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01373   <span class="keywordtype">int</span> pts = 0;
01374   <span class="keywordtype">int</span> alg = 0;
01375 
01376   <span class="comment">/* check parameters */</span>
01377   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"rect_nfa: invalid rectangle."</span>);
01378   <span class="keywordflow">if</span>( angles == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"rect_nfa: invalid 'angles'."</span>);
01379 
01380   <span class="comment">/* compute the total number of pixels and of aligned points in 'rec' */</span>
01381   <span class="keywordflow">for</span>(i=<a class="code" href="lsd_8c.html#a43">ri_ini</a>(rec); !<a class="code" href="lsd_8c.html#a41">ri_end</a>(i); <a class="code" href="lsd_8c.html#a42">ri_inc</a>(i)) <span class="comment">/* rectangle iterator */</span>
01382     <span class="keywordflow">if</span>( i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &gt;= 0 &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &gt;= 0 &amp;&amp;
01383         i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01384       {
01385         ++pts; <span class="comment">/* total number of pixels counter */</span>
01386         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a31">isaligned</a>(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>, i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>, angles, rec-&gt;<a class="code" href="structrect.html#o7">theta</a>, rec-&gt;<a class="code" href="structrect.html#o10">prec</a>) )
01387           ++alg; <span class="comment">/* aligned points counter */</span>
01388       }
01389   <a class="code" href="lsd_8c.html#a40">ri_del</a>(i); <span class="comment">/* delete iterator */</span>
01390 
01391   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a36">nfa</a>(pts,alg,rec-&gt;<a class="code" href="structrect.html#o11">p</a>,logNT); <span class="comment">/* compute NFA value */</span>
01392 }
01393 
01394 
01395 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01396 <span class="comment">/*---------------------------------- Regions ---------------------------------*/</span>
01397 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01398 
01399 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01400 <span class="comment">/** Compute region's angle as the principal inertia axis of the region.</span>
01401 <span class="comment"></span>
01402 <span class="comment">    The following is the region inertia matrix A:</span>
01403 <span class="comment">    @f[</span>
01404 <span class="comment"></span>
01405 <span class="comment">        A = \left(\begin{array}{cc}</span>
01406 <span class="comment">                                    Ixx &amp; Ixy \\</span>
01407 <span class="comment">                                    Ixy &amp; Iyy \\</span>
01408 <span class="comment">             \end{array}\right)</span>
01409 <span class="comment"></span>
01410 <span class="comment">    @f]</span>
01411 <span class="comment">    where</span>
01412 <span class="comment"></span>
01413 <span class="comment">      Ixx =   sum_i G(i).(y_i - cx)^2</span>
01414 <span class="comment"></span>
01415 <span class="comment">      Iyy =   sum_i G(i).(x_i - cy)^2</span>
01416 <span class="comment"></span>
01417 <span class="comment">      Ixy = - sum_i G(i).(x_i - cx).(y_i - cy)</span>
01418 <span class="comment"></span>
01419 <span class="comment">    and</span>
01420 <span class="comment">    - G(i) is the gradient norm at pixel i, used as pixel's weight.</span>
01421 <span class="comment">    - x_i and y_i are the coordinates of pixel i.</span>
01422 <span class="comment">    - cx and cy are the coordinates of the center of th region.</span>
01423 <span class="comment"></span>
01424 <span class="comment">    lambda1 and lambda2 are the eigenvalues of matrix A,</span>
01425 <span class="comment">    with lambda1 &gt;= lambda2. They are found by solving the</span>
01426 <span class="comment">    characteristic polynomial:</span>
01427 <span class="comment"></span>
01428 <span class="comment">      det( lambda I - A) = 0</span>
01429 <span class="comment"></span>
01430 <span class="comment">    that gives:</span>
01431 <span class="comment"></span>
01432 <span class="comment">      lambda1 = ( Ixx + Iyy + sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2</span>
01433 <span class="comment"></span>
01434 <span class="comment">      lambda2 = ( Ixx + Iyy - sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2</span>
01435 <span class="comment"></span>
01436 <span class="comment">    To get the line segment direction we want to get the angle the</span>
01437 <span class="comment">    eigenvector assotiated to the smaller eigenvalue. We have to solve</span>
01438 <span class="comment">    a,b in:</span>
01439 <span class="comment"></span>
01440 <span class="comment">      a.Ixx + b.Ixy = a.lambda2</span>
01441 <span class="comment"></span>
01442 <span class="comment">      a.Ixy + b.Iyy = b.lambda2</span>
01443 <span class="comment"></span>
01444 <span class="comment">    We want the angle theta = atan(b/a). It can be computed with</span>
01445 <span class="comment">    any of the two equations:</span>
01446 <span class="comment"></span>
01447 <span class="comment">      theta = atan( (lambda2-Ixx) / Ixy )</span>
01448 <span class="comment"></span>
01449 <span class="comment">    or</span>
01450 <span class="comment"></span>
01451 <span class="comment">      theta = atan( Ixy / (lambda2-Iyy) )</span>
01452 <span class="comment"></span>
01453 <span class="comment">    When |Ixx| &gt; |Iyy| we use the first, otherwise the second (just to</span>
01454 <span class="comment">    get better numeric precision).</span>
01455 <span class="comment"> */</span>
<a name="l01456"></a><a class="code" href="lsd_8c.html#a45">01456</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a45">get_theta</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> reg_size, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y,
01457                          <a class="code" href="structimage__double__s.html">image_double</a> modgrad, <span class="keywordtype">double</span> reg_angle, <span class="keywordtype">double</span> prec )
01458 {
01459   <span class="keywordtype">double</span> lambda,theta,weight;
01460   <span class="keywordtype">double</span> Ixx = 0.0;
01461   <span class="keywordtype">double</span> Iyy = 0.0;
01462   <span class="keywordtype">double</span> Ixy = 0.0;
01463   <span class="keywordtype">int</span> i;
01464 
01465   <span class="comment">/* check parameters */</span>
01466   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: invalid region."</span>);
01467   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: region size &lt;= 1."</span>);
01468   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01469     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: invalid 'modgrad'."</span>);
01470   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: 'prec' must be positive."</span>);
01471 
01472   <span class="comment">/* compute inertia matrix */</span>
01473   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01474     {
01475       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01476       Ixx += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01477       Iyy += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * weight;
01478       Ixy -= ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01479     }
01480   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a13">double_equal</a>(Ixx,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a13">double_equal</a>(Iyy,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a13">double_equal</a>(Ixy,0.0) )
01481     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"get_theta: null inertia matrix."</span>);
01482 
01483   <span class="comment">/* compute smallest eigenvalue */</span>
01484   lambda = 0.5 * ( Ixx + Iyy - sqrt( (Ixx-Iyy)*(Ixx-Iyy) + 4.0*Ixy*Ixy ) );
01485 
01486   <span class="comment">/* compute angle */</span>
01487   theta = fabs(Ixx)&gt;fabs(Iyy) ? atan2(lambda-Ixx,Ixy) : atan2(Ixy,lambda-Iyy);
01488 
01489   <span class="comment">/* The previous procedure don't cares about orientation,</span>
01490 <span class="comment">     so it could be wrong by 180 degrees. Here is corrected if necessary. */</span>
01491   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a32">angle_diff</a>(theta,reg_angle) &gt; prec ) theta += <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01492 
01493   <span class="keywordflow">return</span> theta;
01494 }
01495 
01496 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01497 <span class="comment">/** Computes a rectangle that covers a region of points.</span>
01498 <span class="comment"> */</span>
<a name="l01499"></a><a class="code" href="lsd_8c.html#a46">01499</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a46">region2rect</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> reg_size,
01500                          <a class="code" href="structimage__double__s.html">image_double</a> modgrad, <span class="keywordtype">double</span> reg_angle,
01501                          <span class="keywordtype">double</span> prec, <span class="keywordtype">double</span> p, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec )
01502 {
01503   <span class="keywordtype">double</span> x,y,dx,dy,l,w,theta,weight,sum,l_min,l_max,w_min,w_max;
01504   <span class="keywordtype">int</span> i;
01505 
01506   <span class="comment">/* check parameters */</span>
01507   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: invalid region."</span>);
01508   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: region size &lt;= 1."</span>);
01509   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01510     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: invalid image 'modgrad'."</span>);
01511   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: invalid 'rec'."</span>);
01512 
01513   <span class="comment">/* center of the region:</span>
01514 <span class="comment"></span>
01515 <span class="comment">     It is computed as the weighted sum of the coordinates</span>
01516 <span class="comment">     of all the pixels in the region. The norm of the gradient</span>
01517 <span class="comment">     is used as the weight of a pixel. The sum is as follows:</span>
01518 <span class="comment">       cx = \sum_i G(i).x_i</span>
01519 <span class="comment">       cy = \sum_i G(i).y_i</span>
01520 <span class="comment">     where G(i) is the norm of the gradient of pixel i</span>
01521 <span class="comment">     and x_i,y_i are its coordinates.</span>
01522 <span class="comment">   */</span>
01523   x = y = sum = 0.0;
01524   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01525     {
01526       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01527       x += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> * weight;
01528       y += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> * weight;
01529       sum += weight;
01530     }
01531   <span class="keywordflow">if</span>( sum &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region2rect: weights sum equal to zero."</span>);
01532   x /= sum;
01533   y /= sum;
01534 
01535   <span class="comment">/* theta */</span>
01536   theta = <a class="code" href="lsd_8c.html#a45">get_theta</a>(reg,reg_size,x,y,modgrad,reg_angle,prec);
01537 
01538   <span class="comment">/* length and width:</span>
01539 <span class="comment"></span>
01540 <span class="comment">     'l' and 'w' are computed as the distance from the center of the</span>
01541 <span class="comment">     region to pixel i, projected along the rectangle axis (dx,dy) and</span>
01542 <span class="comment">     to the orthogonal axis (-dy,dx), respectively.</span>
01543 <span class="comment"></span>
01544 <span class="comment">     The length of the rectangle goes from l_min to l_max, where l_min</span>
01545 <span class="comment">     and l_max are the minimum and maximum values of l in the region.</span>
01546 <span class="comment">     Analogously, the width is selected from w_min to w_max, where</span>
01547 <span class="comment">     w_min and w_max are the minimum and maximum of w for the pixels</span>
01548 <span class="comment">     in the region.</span>
01549 <span class="comment">   */</span>
01550   dx = cos(theta);
01551   dy = sin(theta);
01552   l_min = l_max = w_min = w_max = 0.0;
01553   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01554     {
01555       l =  ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dx + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dy;
01556       w = -( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dy + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dx;
01557 
01558       <span class="keywordflow">if</span>( l &gt; l_max ) l_max = l;
01559       <span class="keywordflow">if</span>( l &lt; l_min ) l_min = l;
01560       <span class="keywordflow">if</span>( w &gt; w_max ) w_max = w;
01561       <span class="keywordflow">if</span>( w &lt; w_min ) w_min = w;
01562     }
01563 
01564   <span class="comment">/* store values */</span>
01565   rec-&gt;<a class="code" href="structrect.html#o0">x1</a> = x + l_min * dx;
01566   rec-&gt;<a class="code" href="structrect.html#o1">y1</a> = y + l_min * dy;
01567   rec-&gt;<a class="code" href="structrect.html#o2">x2</a> = x + l_max * dx;
01568   rec-&gt;<a class="code" href="structrect.html#o3">y2</a> = y + l_max * dy;
01569   rec-&gt;<a class="code" href="structrect.html#o4">width</a> = w_max - w_min;
01570   rec-&gt;<a class="code" href="structrect.html#o5">x</a> = x;
01571   rec-&gt;<a class="code" href="structrect.html#o6">y</a> = y;
01572   rec-&gt;<a class="code" href="structrect.html#o7">theta</a> = theta;
01573   rec-&gt;<a class="code" href="structrect.html#o8">dx</a> = dx;
01574   rec-&gt;<a class="code" href="structrect.html#o9">dy</a> = dy;
01575   rec-&gt;<a class="code" href="structrect.html#o10">prec</a> = prec;
01576   rec-&gt;<a class="code" href="structrect.html#o11">p</a> = p;
01577 
01578   <span class="comment">/* we impose a minimal width of one pixel</span>
01579 <span class="comment"></span>
01580 <span class="comment">     A sharp horizontal or vertical step would produce a perfectly</span>
01581 <span class="comment">     horizontal or vertical region. The width computed would be</span>
01582 <span class="comment">     zero. But that corresponds to a one pixels width transition in</span>
01583 <span class="comment">     the image.</span>
01584 <span class="comment">   */</span>
01585   <span class="keywordflow">if</span>( rec-&gt;<a class="code" href="structrect.html#o4">width</a> &lt; 1.0 ) rec-&gt;<a class="code" href="structrect.html#o4">width</a> = 1.0;
01586 }
01587 
01588 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01589 <span class="comment">/** Build a region of pixels that share the same angle, up to a</span>
01590 <span class="comment">    tolerance 'prec', starting at point (x,y).</span>
01591 <span class="comment"> */</span>
<a name="l01592"></a><a class="code" href="lsd_8c.html#a47">01592</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a47">region_grow</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg,
01593                          <span class="keywordtype">int</span> * reg_size, <span class="keywordtype">double</span> * reg_angle, <a class="code" href="structimage__char__s.html">image_char</a> used,
01594                          <span class="keywordtype">double</span> prec )
01595 {
01596   <span class="keywordtype">double</span> sumdx,sumdy;
01597   <span class="keywordtype">int</span> xx,yy,i;
01598 
01599   <span class="comment">/* check parameters */</span>
01600   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01601     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: (x,y) out of the image."</span>);
01602   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01603     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid image 'angles'."</span>);
01604   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid 'reg'."</span>);
01605   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_size'."</span>);
01606   <span class="keywordflow">if</span>( reg_angle == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_angle'."</span>);
01607   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01608     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"region_grow: invalid image 'used'."</span>);
01609 
01610   <span class="comment">/* first point of the region */</span>
01611   *reg_size = 1;
01612   reg[0].<a class="code" href="structpoint.html#o0">x</a> = x;
01613   reg[0].<a class="code" href="structpoint.html#o1">y</a> = y;
01614   *reg_angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[x+y*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>];  <span class="comment">/* region's angle */</span>
01615   sumdx = cos(*reg_angle);
01616   sumdy = sin(*reg_angle);
01617   used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[x+y*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01618 
01619   <span class="comment">/* try neighbors as new region points */</span>
01620   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01621     <span class="keywordflow">for</span>(xx=reg[i].<a class="code" href="structpoint.html#o0">x</a>-1; xx&lt;=reg[i].x+1; xx++)
01622       <span class="keywordflow">for</span>(yy=reg[i].y-1; yy&lt;=reg[i].y+1; yy++)
01623         <span class="keywordflow">if</span>( xx&gt;=0 &amp;&amp; yy&gt;=0 &amp;&amp; xx&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> &amp;&amp; yy&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> &amp;&amp;
01624             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] != <a class="code" href="lsd_8c.html#a8">USED</a> &amp;&amp;
01625             <a class="code" href="lsd_8c.html#a31">isaligned</a>(xx,yy,angles,*reg_angle,prec) )
01626           {
01627             <span class="comment">/* add point */</span>
01628             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01629             reg[*reg_size].x = xx;
01630             reg[*reg_size].y = yy;
01631             ++(*reg_size);
01632 
01633             <span class="comment">/* update region's angle */</span>
01634             sumdx += cos( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01635             sumdy += sin( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01636             *reg_angle = atan2(sumdy,sumdx);
01637           }
01638 }
01639 
01640 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01641 <span class="comment">/** Try some rectangles variations to improve NFA value. Only if the</span>
01642 <span class="comment">    rectangle is not meaningful (i.e., log_nfa &lt;= eps).</span>
01643 <span class="comment"> */</span>
<a name="l01644"></a><a class="code" href="lsd_8c.html#a48">01644</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a48">rect_improve</a>( <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec, <a class="code" href="structimage__double__s.html">image_double</a> angles,
01645                             <span class="keywordtype">double</span> logNT, <span class="keywordtype">double</span> eps )
01646 {
01647   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> r;
01648   <span class="keywordtype">double</span> log_nfa,log_nfa_new;
01649   <span class="keywordtype">double</span> delta = 0.5;
01650   <span class="keywordtype">double</span> delta_2 = delta / 2.0;
01651   <span class="keywordtype">int</span> n;
01652 
01653   log_nfa = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(rec,angles,logNT);
01654 
01655   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01656 
01657   <span class="comment">/* try finer precisions */</span>
01658   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01659   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01660     {
01661       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01662       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01663       log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01664       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01665         {
01666           log_nfa = log_nfa_new;
01667           <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01668         }
01669     }
01670 
01671   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01672 
01673   <span class="comment">/* try to reduce width */</span>
01674   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01675   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01676     {
01677       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01678         {
01679           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01680           log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01681           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01682             {
01683               <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01684               log_nfa = log_nfa_new;
01685             }
01686         }
01687     }
01688 
01689   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01690 
01691   <span class="comment">/* try to reduce one side of the rectangle */</span>
01692   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01693   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01694     {
01695       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01696         {
01697           r.<a class="code" href="structrect.html#o0">x1</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01698           r.<a class="code" href="structrect.html#o1">y1</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01699           r.<a class="code" href="structrect.html#o2">x2</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01700           r.<a class="code" href="structrect.html#o3">y2</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01701           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01702           log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01703           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01704             {
01705               <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01706               log_nfa = log_nfa_new;
01707             }
01708         }
01709     }
01710 
01711   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01712 
01713   <span class="comment">/* try to reduce the other side of the rectangle */</span>
01714   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01715   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01716     {
01717       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01718         {
01719           r.<a class="code" href="structrect.html#o0">x1</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01720           r.<a class="code" href="structrect.html#o1">y1</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01721           r.<a class="code" href="structrect.html#o2">x2</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01722           r.<a class="code" href="structrect.html#o3">y2</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01723           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01724           log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01725           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01726             {
01727               <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01728               log_nfa = log_nfa_new;
01729             }
01730         }
01731     }
01732 
01733   <span class="keywordflow">if</span>( log_nfa &gt; eps ) <span class="keywordflow">return</span> log_nfa;
01734 
01735   <span class="comment">/* try even finer precisions */</span>
01736   <a class="code" href="lsd_8c.html#a37">rect_copy</a>(rec,&amp;r);
01737   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01738     {
01739       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01740       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01741       log_nfa_new = <a class="code" href="lsd_8c.html#a44">rect_nfa</a>(&amp;r,angles,logNT);
01742       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01743         {
01744           log_nfa = log_nfa_new;
01745           <a class="code" href="lsd_8c.html#a37">rect_copy</a>(&amp;r,rec);
01746         }
01747     }
01748 
01749   <span class="keywordflow">return</span> log_nfa;
01750 }
01751 
01752 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01753 <span class="comment">/** Reduce the region size, by elimination the points far from the</span>
01754 <span class="comment">    starting point, until that leads to rectangle with the right</span>
01755 <span class="comment">    density of region points or to discard the region if too small.</span>
01756 <span class="comment"> */</span>
<a name="l01757"></a><a class="code" href="lsd_8c.html#a49">01757</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a49">reduce_region_radius</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> * reg_size,
01758                                  <a class="code" href="structimage__double__s.html">image_double</a> modgrad, <span class="keywordtype">double</span> reg_angle,
01759                                  <span class="keywordtype">double</span> prec, <span class="keywordtype">double</span> p, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec,
01760                                  <a class="code" href="structimage__char__s.html">image_char</a> used, <a class="code" href="structimage__double__s.html">image_double</a> angles,
01761                                  <span class="keywordtype">double</span> density_th )
01762 {
01763   <span class="keywordtype">double</span> density,rad1,rad2,rad,xc,yc;
01764   <span class="keywordtype">int</span> i;
01765 
01766   <span class="comment">/* check parameters */</span>
01767   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg'."</span>);
01768   <span class="keywordflow">if</span>( reg_size == NULL )
01769     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg_size'."</span>);
01770   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: 'prec' must be positive."</span>);
01771   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'rec'."</span>);
01772   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01773     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'used'."</span>);
01774   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01775     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'angles'."</span>);
01776 
01777   <span class="comment">/* compute region points density */</span>
01778   density = (<span class="keywordtype">double</span>) *reg_size /
01779                          ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01780 
01781   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01782   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01783 
01784   <span class="comment">/* compute region's radius */</span>
01785   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01786   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01787   rad1 = <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o0">x1</a>, rec-&gt;<a class="code" href="structrect.html#o1">y1</a> );
01788   rad2 = <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o2">x2</a>, rec-&gt;<a class="code" href="structrect.html#o3">y2</a> );
01789   rad = rad1 &gt; rad2 ? rad1 : rad2;
01790 
01791   <span class="comment">/* while the density criterion is not satisfied, remove farther pixels */</span>
01792   <span class="keywordflow">while</span>( density &lt; density_th )
01793     {
01794       rad *= 0.75; <span class="comment">/* reduce region's radius to 75% of its value */</span>
01795 
01796       <span class="comment">/* remove points from the region and update 'used' map */</span>
01797       <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01798         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &gt; rad )
01799           {
01800             <span class="comment">/* point not kept, mark it as NOTUSED */</span>
01801             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01802             <span class="comment">/* remove point from the region */</span>
01803             reg[i].<a class="code" href="structpoint.html#o0">x</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o0">x</a>; <span class="comment">/* if i==*reg_size-1 copy itself */</span>
01804             reg[i].<a class="code" href="structpoint.html#o1">y</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o1">y</a>;
01805             --(*reg_size);
01806             --i; <span class="comment">/* to avoid skipping one point */</span>
01807           }
01808 
01809       <span class="comment">/* reject if the region is too small.</span>
01810 <span class="comment">         2 is the minimal region size for 'region2rect' to work. */</span>
01811       <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01812 
01813       <span class="comment">/* re-compute rectangle */</span>
01814       <a class="code" href="lsd_8c.html#a46">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01815 
01816       <span class="comment">/* re-compute region points density */</span>
01817       density = (<span class="keywordtype">double</span>) *reg_size /
01818                          ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01819     }
01820 
01821   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01822   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01823 }
01824 
01825 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01826 <span class="comment">/** Refine a rectangle.</span>
01827 <span class="comment"></span>
01828 <span class="comment">    For that, an estimation of the angle tolerance is performed by the</span>
01829 <span class="comment">    standard deviation of the angle at points near the region's</span>
01830 <span class="comment">    starting point. Then, a new region is grown starting from the same</span>
01831 <span class="comment">    point, but using the estimated angle tolerance. If this fails to</span>
01832 <span class="comment">    produce a rectangle with the right density of region points,</span>
01833 <span class="comment">    'reduce_region_radius' is called to try to satisfy this condition.</span>
01834 <span class="comment"> */</span>
<a name="l01835"></a><a class="code" href="lsd_8c.html#a50">01835</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a50">refine</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> * reg_size, <a class="code" href="structimage__double__s.html">image_double</a> modgrad,
01836                    <span class="keywordtype">double</span> reg_angle, <span class="keywordtype">double</span> prec, <span class="keywordtype">double</span> p, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec,
01837                    <a class="code" href="structimage__char__s.html">image_char</a> used, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keywordtype">double</span> density_th )
01838 {
01839   <span class="keywordtype">double</span> angle,ang_d,mean_angle,tau,density,xc,yc,ang_c,sum,s_sum;
01840   <span class="keywordtype">int</span> i,n;
01841 
01842   <span class="comment">/* check parameters */</span>
01843   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg'."</span>);
01844   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg_size'."</span>);
01845   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: 'prec' must be positive."</span>);
01846   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid pointer 'rec'."</span>);
01847   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01848     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid image 'used'."</span>);
01849   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01850     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"refine: invalid image 'angles'."</span>);
01851 
01852   <span class="comment">/* compute region points density */</span>
01853   density = (<span class="keywordtype">double</span>) *reg_size /
01854                          ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01855 
01856   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01857   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01858 
01859   <span class="comment">/*------ First try: reduce angle tolerance ------*/</span>
01860 
01861   <span class="comment">/* compute the new mean angle and tolerance */</span>
01862   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01863   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01864   ang_c = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[0].<a class="code" href="structpoint.html#o0">x</a> + reg[0].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01865   sum = s_sum = 0.0;
01866   n = 0;
01867   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01868     {
01869       used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01870       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a14">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &lt; rec-&gt;<a class="code" href="structrect.html#o4">width</a> )
01871         {
01872           angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01873           ang_d = <a class="code" href="lsd_8c.html#a33">angle_diff_signed</a>(angle,ang_c);
01874           sum += ang_d;
01875           s_sum += ang_d * ang_d;
01876           ++n;
01877         }
01878     }
01879   mean_angle = sum / (<span class="keywordtype">double</span>) n;
01880   tau = 2.0 * sqrt( (s_sum - 2.0 * mean_angle * sum) / (<span class="keywordtype">double</span>) n
01881                          + mean_angle*mean_angle ); <span class="comment">/* 2 * standard deviation */</span>
01882 
01883   <span class="comment">/* find a new region from the same starting point and new angle tolerance */</span>
01884   <a class="code" href="lsd_8c.html#a47">region_grow</a>(reg[0].x,reg[0].y,angles,reg,reg_size,&amp;reg_angle,used,tau);
01885 
01886   <span class="comment">/* if the region is too small, reject */</span>
01887   <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01888 
01889   <span class="comment">/* re-compute rectangle */</span>
01890   <a class="code" href="lsd_8c.html#a46">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01891 
01892   <span class="comment">/* re-compute region points density */</span>
01893   density = (<span class="keywordtype">double</span>) *reg_size /
01894                       ( <a class="code" href="lsd_8c.html#a14">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01895 
01896   <span class="comment">/*------ Second try: reduce region radius ------*/</span>
01897   <span class="keywordflow">if</span>( density &lt; density_th )
01898     <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a49">reduce_region_radius</a>( reg, reg_size, modgrad, reg_angle, prec, p,
01899                                  rec, used, angles, density_th );
01900 
01901   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01902   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01903 }
01904 
01905 
01906 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01907 <span class="comment">/*-------------------------- Line Segment Detector ---------------------------*/</span>
01908 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01909 
01910 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01911 <span class="comment">/** LSD full interface.</span>
01912 <span class="comment"> */</span>
<a name="l01913"></a><a class="code" href="lsd_8c.html#a51">01913</a> <a class="code" href="structntuple__list__s.html">ntuple_list</a> <a class="code" href="lsd_8c.html#a51">LineSegmentDetection</a>( <a class="code" href="structimage__double__s.html">image_double</a> image, <span class="keywordtype">double</span> scale,
01914                                   <span class="keywordtype">double</span> sigma_scale, <span class="keywordtype">double</span> quant,
01915                                   <span class="keywordtype">double</span> ang_th, <span class="keywordtype">double</span> eps, <span class="keywordtype">double</span> density_th,
01916                                   <span class="keywordtype">int</span> n_bins, <span class="keywordtype">double</span> max_grad,
01917                                   <a class="code" href="structimage__int__s.html">image_int</a> * region )
01918 {
01919   <a class="code" href="structntuple__list__s.html">ntuple_list</a> out = <a class="code" href="lsd_8c.html#a16">new_ntuple_list</a>(5);
01920   <a class="code" href="structimage__double__s.html">image_double</a> scaled_image,angles,modgrad;
01921   <a class="code" href="structimage__char__s.html">image_char</a> used;
01922   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list_p;
01923   <span class="keywordtype">void</span> * mem_p;
01924   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> rec;
01925   <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> * reg;
01926   <span class="keywordtype">int</span> reg_size,min_reg_size,i;
01927   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,ysize;
01928   <span class="keywordtype">double</span> rho,reg_angle,prec,p,log_nfa,logNT;
01929   <span class="keywordtype">int</span> ls_count = 0;                   <span class="comment">/* line segments are numbered 1,2,3,... */</span>
01930 
01931 
01932   <span class="comment">/* check parameters */</span>
01933   <span class="keywordflow">if</span>( image==NULL || image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>==NULL || image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>==0 || image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>==0 )
01934     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"invalid image input."</span>);
01935   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'scale' value must be positive."</span>);
01936   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'sigma_scale' value must be positive."</span>);
01937   <span class="keywordflow">if</span>( quant &lt; 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'quant' value must be positive."</span>);
01938   <span class="keywordflow">if</span>( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )
01939     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'ang_th' value must be in the range (0,180)."</span>);
01940   <span class="keywordflow">if</span>( density_th &lt; 0.0 || density_th &gt; 1.0 )
01941     <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'density_th' value must be in the range [0,1]."</span>);
01942   <span class="keywordflow">if</span>( n_bins &lt;= 0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'n_bins' value must be positive."</span>);
01943   <span class="keywordflow">if</span>( max_grad &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"'max_grad' value must be positive."</span>);
01944 
01945 
01946   <span class="comment">/* angle tolerance */</span>
01947   prec = <a class="code" href="lsd_8c.html#a1">M_PI</a> * ang_th / 180.0;
01948   p = ang_th / 180.0;
01949   rho = quant / sin(prec); <span class="comment">/* gradient magnitude threshold */</span>
01950 
01951 
01952   <span class="comment">/* scale image (if necessary) and compute angle at each pixel */</span>
01953   <span class="keywordflow">if</span>( scale != 1.0 )
01954     {
01955       scaled_image = <a class="code" href="lsd_8c.html#a29">gaussian_sampler</a>( image, scale, sigma_scale );
01956       angles = <a class="code" href="lsd_8c.html#a30">ll_angle</a>( scaled_image, rho, &amp;list_p, &amp;mem_p,
01957                          &amp;modgrad, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins, max_grad );
01958       <a class="code" href="lsd_8c.html#a25">free_image_double</a>(scaled_image);
01959     }
01960   <span class="keywordflow">else</span>
01961     angles = <a class="code" href="lsd_8c.html#a30">ll_angle</a>( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,
01962                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins, max_grad );
01963   xsize = angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
01964   ysize = angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
01965   logNT = 5.0 * ( log10( (<span class="keywordtype">double</span>) xsize ) + log10( (<span class="keywordtype">double</span>) ysize ) ) / 2.0;
01966   min_reg_size = (<span class="keywordtype">int</span>) (-logNT/log10(p)); <span class="comment">/* minimal number of points in region</span>
01967 <span class="comment">                                             that can give a meaningful event */</span>
01968 
01969 
01970   <span class="comment">/* initialize some structures */</span>
01971   <span class="keywordflow">if</span>( region != NULL ) <span class="comment">/* image to output pixel region number, if asked */</span>
01972     *region = <a class="code" href="lsd_8c.html#a24">new_image_int_ini</a>(angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>,0);
01973   used = <a class="code" href="lsd_8c.html#a21">new_image_char_ini</a>(xsize,ysize,<a class="code" href="lsd_8c.html#a7">NOTUSED</a>);
01974   reg = (<span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a>) );
01975   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a12">error</a>(<span class="stringliteral">"not enough memory!"</span>);
01976 
01977 
01978   <span class="comment">/* search for line segments */</span>
01979   <span class="keywordflow">for</span>(; list_p != NULL; list_p = list_p-&gt;next )
01980     <span class="keywordflow">if</span>( used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] == <a class="code" href="lsd_8c.html#a7">NOTUSED</a> &amp;&amp;
01981         angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] != <a class="code" href="lsd_8c.html#a4">NOTDEF</a> )
01982        <span class="comment">/* there is no risk of double comparison problems here</span>
01983 <span class="comment">          because we are only interested in the exact NOTDEF value */</span>
01984       {
01985         <span class="comment">/* find the region of connected point and ~equal angle */</span>
01986         <a class="code" href="lsd_8c.html#a47">region_grow</a>( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,
01987                      &amp;reg_angle, used, prec );
01988 
01989         <span class="comment">/* reject small regions */</span>
01990         <span class="keywordflow">if</span>( reg_size &lt; min_reg_size ) <span class="keywordflow">continue</span>;
01991 
01992         <span class="comment">/* construct rectangular approximation for the region */</span>
01993         <a class="code" href="lsd_8c.html#a46">region2rect</a>(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);
01994 
01995         <span class="comment">/* Check if the rectangle exceeds the minimal density of</span>
01996 <span class="comment">           region points. If not, try to improve the region.</span>
01997 <span class="comment">           The rectangle will be rejected if the final one does</span>
01998 <span class="comment">           not fulfill the minimal density condition.</span>
01999 <span class="comment">           This is an addition to the original LSD algorithm published in</span>
02000 <span class="comment">           "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
02001 <span class="comment">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</span>
02002 <span class="comment">           The original algorithm is obtained with density_th = 0.0.</span>
02003 <span class="comment">         */</span>
02004         <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a50">refine</a>( reg, &amp;reg_size, modgrad, reg_angle,
02005                      prec, p, &amp;rec, used, angles, density_th ) ) <span class="keywordflow">continue</span>;
02006 
02007         <span class="comment">/* compute NFA value */</span>
02008         log_nfa = <a class="code" href="lsd_8c.html#a48">rect_improve</a>(&amp;rec,angles,logNT,eps);
02009         <span class="keywordflow">if</span>( log_nfa &lt;= eps ) <span class="keywordflow">continue</span>;
02010 
02011         <span class="comment">/* A New Line Segment was found! */</span>
02012         ++ls_count;  <span class="comment">/* increase line segment counter */</span>
02013 
02014         <span class="comment">/*</span>
02015 <span class="comment">           The gradient was computed with a 2x2 mask, its value corresponds to</span>
02016 <span class="comment">           points with an offset of (0.5,0.5), that should be added to output.</span>
02017 <span class="comment">           The coordinates origin is at the center of pixel (0,0).</span>
02018 <span class="comment">         */</span>
02019         rec.<a class="code" href="structrect.html#o0">x1</a> += 0.5; rec.<a class="code" href="structrect.html#o1">y1</a> += 0.5;
02020         rec.<a class="code" href="structrect.html#o2">x2</a> += 0.5; rec.<a class="code" href="structrect.html#o3">y2</a> += 0.5;
02021 
02022         <span class="comment">/* scale the result values if a subsampling was performed */</span>
02023         <span class="keywordflow">if</span>( scale != 1.0 )
02024           {
02025             rec.<a class="code" href="structrect.html#o0">x1</a> /= scale; rec.<a class="code" href="structrect.html#o1">y1</a> /= scale;
02026             rec.<a class="code" href="structrect.html#o2">x2</a> /= scale; rec.<a class="code" href="structrect.html#o3">y2</a> /= scale;
02027             rec.<a class="code" href="structrect.html#o4">width</a> /= scale;
02028           }
02029 
02030         <span class="comment">/* add line segment found to output */</span>
02031         <a class="code" href="lsd_8c.html#a18">add_5tuple</a>(out, rec.<a class="code" href="structrect.html#o0">x1</a>, rec.<a class="code" href="structrect.html#o1">y1</a>, rec.<a class="code" href="structrect.html#o2">x2</a>, rec.<a class="code" href="structrect.html#o3">y2</a>, rec.<a class="code" href="structrect.html#o4">width</a>);
02032 
02033         <span class="comment">/* add region number to 'region' image if needed */</span>
02034         <span class="keywordflow">if</span>( region != NULL )
02035           <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
02036             (*region)-&gt;data[reg[i].x+reg[i].y*(*region)-&gt;xsize] = ls_count;
02037       }
02038 
02039 
02040   <span class="comment">/* free memory */</span>
02041   <a class="code" href="lsd_8c.html#a25">free_image_double</a>(angles);
02042   <a class="code" href="lsd_8c.html#a25">free_image_double</a>(modgrad);
02043   <a class="code" href="lsd_8c.html#a19">free_image_char</a>(used);
02044   free( (<span class="keywordtype">void</span> *) reg );
02045   free( (<span class="keywordtype">void</span> *) mem_p );
02046 
02047   <span class="keywordflow">return</span> out;
02048 }
02049 
02050 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
02051 <span class="comment">/** LSD Simple Interface with Scale.</span>
02052 <span class="comment"> */</span>
<a name="l02053"></a><a class="code" href="lsd_8c.html#a52">02053</a> <a class="code" href="structntuple__list__s.html">ntuple_list</a> <a class="code" href="lsd_8c.html#a52">lsd_scale</a>(<a class="code" href="structimage__double__s.html">image_double</a> image, <span class="keywordtype">double</span> scale)
02054 {
02055   <span class="comment">/* LSD parameters */</span>
02056   <span class="keywordtype">double</span> sigma_scale = 0.6; <span class="comment">/* Sigma for Gaussian filter is computed as</span>
02057 <span class="comment">                                sigma = sigma_scale/scale.                    */</span>
02058   <span class="keywordtype">double</span> quant = 2.0;       <span class="comment">/* Bound to the quantization error on the</span>
02059 <span class="comment">                                gradient norm.                                */</span>
02060   <span class="keywordtype">double</span> ang_th = 22.5;     <span class="comment">/* Gradient angle tolerance in degrees.           */</span>
02061   <span class="keywordtype">double</span> eps = 0.0;         <span class="comment">/* Detection threshold, -log10(NFA).              */</span>
02062   <span class="keywordtype">double</span> density_th = 0.7;  <span class="comment">/* Minimal density of region points in rectangle. */</span>
02063   <span class="keywordtype">int</span> n_bins = 1024;        <span class="comment">/* Number of bins in pseudo-ordering of gradient</span>
02064 <span class="comment">                               modulus.                                       */</span>
02065   <span class="keywordtype">double</span> max_grad = 255.0;  <span class="comment">/* Gradient modulus in the highest bin. The</span>
02066 <span class="comment">                               default value corresponds to the highest</span>
02067 <span class="comment">                               gradient modulus on images with gray</span>
02068 <span class="comment">                               levels in [0,255].                             */</span>
02069 
02070   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a51">LineSegmentDetection</a>( image, scale, sigma_scale, quant, ang_th, eps,
02071                                density_th, n_bins, max_grad, NULL );
02072 }
02073 
02074 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
02075 <span class="comment">/** LSD Simple Interface.</span>
02076 <span class="comment"> */</span>
<a name="l02077"></a><a class="code" href="lsd_8c.html#a53">02077</a> <a class="code" href="structntuple__list__s.html">ntuple_list</a> <a class="code" href="lsd_8c.html#a53">lsd</a>(<a class="code" href="structimage__double__s.html">image_double</a> image)
02078 {
02079   <span class="comment">/* LSD parameters */</span>
02080   <span class="keywordtype">double</span> scale = 0.8;       <span class="comment">/* Scale the image by Gaussian filter to 'scale'. */</span>
02081 
02082   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a52">lsd_scale</a>(image,scale);
02083 }
02084 <span class="comment">/*----------------------------------------------------------------------------*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 3 10:18:18 2010 for LSD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
